{"ast":null,"code":"// import React, { useRef, useEffect, useState } from 'react';\n// import spriteImage from './Images/background.png';\n// import { Center, Flex, position } from '@chakra-ui/react';\n\n// const Canvas = (props) => {\n//   const canvasRef = useRef(null);\n//   let player;\n//   let enemy;\n//   let backgroundImage;\n//   let timer = 60;\n//   let timerId;\n//   const keys = {\n//     a: {\n//       pressed: false,\n//     },\n//     d: {\n//       pressed: false,\n//     },\n//     ArrowRight: {\n//       pressed: false,\n//     },\n//     ArrowLeft: {\n//       pressed: false,\n//     },\n//   };\n//   let lastkey = ''; // Initialize lastkey with an empty string\n\n//   function determineWinner({ player, enemy, timerId }){\n//     clearTimeout(timerId);\n//     document.querySelector('#displayText').style.display = 'flex';\n//       if (player.health === enemy.health){\n//         document.querySelector('#displayText').innerHTML = 'Tie';\n//       }\n//       else if(player.health > enemy.health){\n//         document.querySelector('#displayText').innerHTML = 'Player 1 Wins!!';\n//       }\n//       else if(enemy.health > player.health){\n//         document.querySelector('#displayText').innerHTML = 'Player 2 Wins!!';\n//       }\n//   }\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     player = new Sprite({\n//       position: { x: 150, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//       offset: {\n//         x:0,\n//         y: 0\n//       }\n//     });\n\n//     enemy = new Sprite({\n//       position: { x: 450, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//       offset: {\n//         x:50,\n//         y:0\n//       },\n//       color: 'blue'\n\n//     });\n\n//     backgroundImage.onload = () => {\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Draw the initial sprites\n//       player.draw(ctx);\n//       enemy.draw(ctx);\n//     };\n\n//     // Event listeners\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     function handleKeyDown(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = true;\n//           lastkey = 'd';\n//           break;\n//         case 'a':\n//           keys.a.pressed = true;\n//           lastkey = 'a';\n//           break;\n//           case ' ':\n//             player.attack()  \n//             break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = true;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = true;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//           case 'ArrowDown':\n//             enemy.isAttacking = true;\n//             break\n//       }\n//     }\n\n//     function handleKeyUp(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = false;\n//           break;\n//         case 'a':\n//           keys.a.pressed = false;\n//           break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = false;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = false;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//       }\n//     }\n//   function decreaseTimer() {\n//     if (timer > 0 && player.health > 0 && enemy.health > 0) {\n//       timerId = setTimeout(() => {\n//         timer--;\n//         document.querySelector('#timer').innerHTML = timer;\n//         decreaseTimer(); // Call itself for the next second\n//       }, 1000);\n//     }\n\n//     if (player.health <= 0 || enemy.health <= 0) {\n//       determineWinner({ player, enemy, timerId });\n//     }\n//   }\n\n//     decreaseTimer(); // Start the countdown\n\n//   }, []);\n\n//   const gravity = 0.007;\n\n//   class Sprite {\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\n//       this.position = position;\n//       this.velocity = velocity;\n//       this.height = 150;\n//       this.width = 50;\n//       this.attackbox = {\n//         position: {\n//           x:this.position.x,\n//           y:this.position.y\n//         },\n//         offset,\n\n//         width: 100 ,\n//         height: 50\n//       }\n//       this.isAttacking = '';\n//       this.color = color;\n//       this.health = 100\n//     }\n\n//     draw(ctx) {\n//       ctx.fillStyle = this.color;\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\n//       //attack box\n//       if (this.isAttacking) {\n\n//       ctx.fillStyle = 'green';\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\n//     }\n//   }\n\n//     update(ctx) {\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\n//       this.attackbox.position.y = this.position.y;\n\n//       this.position.x += this.velocity.x;\n//       this.position.y += this.velocity.y;\n//       if (this.position.y + this.height >= ctx.height) {\n//         this.velocity.y = 0;\n//         this.position.y = ctx.height - this.height;\n//       } else {\n//         this.velocity.y += gravity;\n//       }\n//     }\n//       attack() {\n//         this.isAttacking = true\n//         setTimeout(() => {\n//           this.isAttacking = false\n//         }, 100);\n//       }\n//     }\n\n//   function rectangularCollision({rectangle1, rectangle2}) {\n//     return (\n//       rectangle1.attackbox.position.x + rectangle1.attackbox.width >= \n//       rectangle2.position.x && rectangle1.attackbox.position.x <= rectangle2.position.x + rectangle2.width &&\n//         rectangle1.attackbox.position.y + rectangle1.attackbox.height >= rectangle2.position.y\n//         && rectangle1.attackbox.position.y <= rectangle2.position.y + rectangle2.height\n\n//     );\n//   }\n\n//   function animate() {\n//     const canvas = canvasRef.current;\n\n//      if (canvas && player && enemy) {\n//       const ctx = canvas.getContext('2d');\n\n//       // Clear the canvas\n//       ctx.fillStyle = 'black';\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Update and draw the sprites\n//       player.update(canvas);\n//       player.draw(ctx);\n\n//       enemy.update(canvas);\n//       enemy.draw(ctx);\n\n//       player.velocity.x = 0;\n//       enemy.velocity.x = 0;\n\n//       if (keys.a.pressed && lastkey === 'a') {\n//         player.velocity.x = -5;\n//       } else if (keys.d.pressed && lastkey === 'd') {\n//         player.velocity.x = 5;\n//       }\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\n//         enemy.velocity.x = -5;\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\n//         enemy.velocity.x = 5;\n//       }\n//       // detect for collision\n//       if (rectangularCollision({\n//         rectangle1: player,\n//         rectangle2: enemy\n//       }) &&\n//         player.isAttacking) {\n//           player.isAttacking = false\n//           enemy.health -= 20\n//         document.querySelector('#enemyHealth').style.width = enemy.health + '%'\n//         console.log('go');\n//       }\n\n//       if (rectangularCollision({\n//         rectangle1: enemy,\n//         rectangle2: player\n//       }) &&\n//         enemy.isAttacking) {\n//           enemy.isAttacking = false\n//           player.health -= 20\n//             document.querySelector('#playerHealth').style.width = player.health + '%'\n//         console.log('enemy attack successful');\n//       }\n\n//       // end game based on health\n//       if(player.health <= 0 || player.health <=0) {\n//         determineWinner({ player, enemy, timerId });\n//       }\n\n//     }\n\n//     window.requestAnimationFrame(animate);\n//   }\n\n//   useEffect(() => {\n//     animate(); // Start the animation loop after the initial render\n//   }, []);\n\n// return (\n//   <div style={{ position: 'relative', display: 'inline-block' }}>\n//     <div\n//       style={{\n//         position: 'absolute',\n//         display: 'flex',\n//         width: '100%',\n//         alignItems: 'center',\n//         padding: '20px',\n//       }}\n//     >\n//       {/* Player Health Bar */}\n//       <div style={{ position: 'relative', height: '30px', width: '100%', display: 'flex', justifyContent: 'flex-end' }}>\n//         <div style={{ backgroundColor: 'yellow', height: '30px', width: '100%' }}></div>\n//         <div\n//           id=\"playerHealth\"\n//           style={{\n//             position: 'absolute',\n//             background: 'blue',\n//             top: 0,\n//             right: 0,\n//             bottom: 0,\n//             width: '100%',\n//           }}\n//         ></div>\n//       </div>\n\n//       {/* Timer */}\n//       <div\n//       id = \"timer\"\n//        style={{ \n//         backgroundColor: 'red', \n//         width: '100px', \n//         height: '100px', \n//         flexShrink: 0,\n//         display: 'flex',\n//         alignItems: 'center',\n//         justifyContent: 'center',\n//         }}\n//       >\n//         {timer}\n//       </div>\n\n//       {/* Enemy Health Bar */}\n//       <div style={{ position: 'relative', height: '30px', width: '100%' }}>\n//         <div style={{ backgroundColor: 'yellow', height: '30px' }}></div>\n//         <div\n//           id=\"enemyHealth\"\n//           style={{\n//             position: 'absolute',\n//             background: 'blue',\n//             top: 0,\n//             right: 0,\n//             bottom: 0,\n//             left: 0,\n//           }}\n//         ></div>\n//       </div>\n//       <div></div>\n//     </div>\n//     <div\n//     id=\"displayText\"\n//      style={{\n//       position: 'absolute', \n//       color: 'black',\n//       alignItems: 'center', \n//       justifyContent:'center',\n//       top: 0,\n//       right : 0,\n//       bottom : 0,\n//       left: 0,\n//       display: 'none'\n//       }}>Tie\n//       </div>\n//     <canvas ref={canvasRef} style={{ boxSizing: 'border-box' }} {...props} />\n//   </div>\n// );\n// };\n\n// export default Canvas;","map":{"version":3,"names":[],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/Canvas.jsx"],"sourcesContent":["// import React, { useRef, useEffect, useState } from 'react';\r\n// import spriteImage from './Images/background.png';\r\n// import { Center, Flex, position } from '@chakra-ui/react';\r\n\r\n// const Canvas = (props) => {\r\n//   const canvasRef = useRef(null);\r\n//   let player;\r\n//   let enemy;\r\n//   let backgroundImage;\r\n//   let timer = 60;\r\n//   let timerId;\r\n//   const keys = {\r\n//     a: {\r\n//       pressed: false,\r\n//     },\r\n//     d: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowRight: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowLeft: {\r\n//       pressed: false,\r\n//     },\r\n//   };\r\n//   let lastkey = ''; // Initialize lastkey with an empty string\r\n\r\n//   function determineWinner({ player, enemy, timerId }){\r\n//     clearTimeout(timerId);\r\n//     document.querySelector('#displayText').style.display = 'flex';\r\n//       if (player.health === enemy.health){\r\n//         document.querySelector('#displayText').innerHTML = 'Tie';\r\n//       }\r\n//       else if(player.health > enemy.health){\r\n//         document.querySelector('#displayText').innerHTML = 'Player 1 Wins!!';\r\n//       }\r\n//       else if(enemy.health > player.health){\r\n//         document.querySelector('#displayText').innerHTML = 'Player 2 Wins!!';\r\n//       }\r\n//   }\r\n  \r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n\r\n//     player = new Sprite({\r\n//       position: { x: 150, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//       offset: {\r\n//         x:0,\r\n//         y: 0\r\n//       }\r\n//     });\r\n\r\n//     enemy = new Sprite({\r\n//       position: { x: 450, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//       offset: {\r\n//         x:50,\r\n//         y:0\r\n//       },\r\n//       color: 'blue'\r\n\r\n//     });\r\n\r\n//     backgroundImage.onload = () => {\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the initial sprites\r\n//       player.draw(ctx);\r\n//       enemy.draw(ctx);\r\n//     };\r\n\r\n//     // Event listeners\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n\r\n//     function handleKeyDown(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = true;\r\n//           lastkey = 'd';\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = true;\r\n//           lastkey = 'a';\r\n//           break;\r\n//           case ' ':\r\n//             player.attack()  \r\n//             break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = true;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = true;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//           case 'ArrowDown':\r\n//             enemy.isAttacking = true;\r\n//             break\r\n//       }\r\n//     }\r\n\r\n//     function handleKeyUp(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = false;\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = false;\r\n//           break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = false;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = false;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//       }\r\n//     }\r\n//   function decreaseTimer() {\r\n//     if (timer > 0 && player.health > 0 && enemy.health > 0) {\r\n//       timerId = setTimeout(() => {\r\n//         timer--;\r\n//         document.querySelector('#timer').innerHTML = timer;\r\n//         decreaseTimer(); // Call itself for the next second\r\n//       }, 1000);\r\n//     }\r\n  \r\n//     if (player.health <= 0 || enemy.health <= 0) {\r\n//       determineWinner({ player, enemy, timerId });\r\n//     }\r\n//   }\r\n  \r\n//     decreaseTimer(); // Start the countdown\r\n\r\n//   }, []);\r\n\r\n//   const gravity = 0.007;\r\n\r\n//   class Sprite {\r\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\r\n//       this.position = position;\r\n//       this.velocity = velocity;\r\n//       this.height = 150;\r\n//       this.width = 50;\r\n//       this.attackbox = {\r\n//         position: {\r\n//           x:this.position.x,\r\n//           y:this.position.y\r\n//         },\r\n//         offset,\r\n        \r\n//         width: 100 ,\r\n//         height: 50\r\n//       }\r\n//       this.isAttacking = '';\r\n//       this.color = color;\r\n//       this.health = 100\r\n//     }\r\n\r\n//     draw(ctx) {\r\n//       ctx.fillStyle = this.color;\r\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\r\n//       //attack box\r\n//       if (this.isAttacking) {\r\n\r\n      \r\n//       ctx.fillStyle = 'green';\r\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\r\n//     }\r\n//   }\r\n\r\n//     update(ctx) {\r\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\r\n//       this.attackbox.position.y = this.position.y;\r\n\r\n//       this.position.x += this.velocity.x;\r\n//       this.position.y += this.velocity.y;\r\n//       if (this.position.y + this.height >= ctx.height) {\r\n//         this.velocity.y = 0;\r\n//         this.position.y = ctx.height - this.height;\r\n//       } else {\r\n//         this.velocity.y += gravity;\r\n//       }\r\n//     }\r\n//       attack() {\r\n//         this.isAttacking = true\r\n//         setTimeout(() => {\r\n//           this.isAttacking = false\r\n//         }, 100);\r\n//       }\r\n//     }\r\n\r\n  \r\n//   function rectangularCollision({rectangle1, rectangle2}) {\r\n//     return (\r\n//       rectangle1.attackbox.position.x + rectangle1.attackbox.width >= \r\n//       rectangle2.position.x && rectangle1.attackbox.position.x <= rectangle2.position.x + rectangle2.width &&\r\n//         rectangle1.attackbox.position.y + rectangle1.attackbox.height >= rectangle2.position.y\r\n//         && rectangle1.attackbox.position.y <= rectangle2.position.y + rectangle2.height\r\n\r\n//     );\r\n//   }\r\n \r\n\r\n//   function animate() {\r\n//     const canvas = canvasRef.current;\r\n\r\n//      if (canvas && player && enemy) {\r\n//       const ctx = canvas.getContext('2d');\r\n\r\n//       // Clear the canvas\r\n//       ctx.fillStyle = 'black';\r\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Update and draw the sprites\r\n//       player.update(canvas);\r\n//       player.draw(ctx);\r\n\r\n//       enemy.update(canvas);\r\n//       enemy.draw(ctx);\r\n\r\n//       player.velocity.x = 0;\r\n//       enemy.velocity.x = 0;\r\n\r\n\r\n//       if (keys.a.pressed && lastkey === 'a') {\r\n//         player.velocity.x = -5;\r\n//       } else if (keys.d.pressed && lastkey === 'd') {\r\n//         player.velocity.x = 5;\r\n//       }\r\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\r\n//         enemy.velocity.x = -5;\r\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\r\n//         enemy.velocity.x = 5;\r\n//       }\r\n//       // detect for collision\r\n//       if (rectangularCollision({\r\n//         rectangle1: player,\r\n//         rectangle2: enemy\r\n//       }) &&\r\n//         player.isAttacking) {\r\n//           player.isAttacking = false\r\n//           enemy.health -= 20\r\n//         document.querySelector('#enemyHealth').style.width = enemy.health + '%'\r\n//         console.log('go');\r\n//       }\r\n      \r\n//       if (rectangularCollision({\r\n//         rectangle1: enemy,\r\n//         rectangle2: player\r\n//       }) &&\r\n//         enemy.isAttacking) {\r\n//           enemy.isAttacking = false\r\n//           player.health -= 20\r\n//             document.querySelector('#playerHealth').style.width = player.health + '%'\r\n//         console.log('enemy attack successful');\r\n//       }\r\n    \r\n//       // end game based on health\r\n//       if(player.health <= 0 || player.health <=0) {\r\n//         determineWinner({ player, enemy, timerId });\r\n//       }\r\n    \r\n//     }\r\n    \r\n//     window.requestAnimationFrame(animate);\r\n//   }\r\n\r\n//   useEffect(() => {\r\n//     animate(); // Start the animation loop after the initial render\r\n//   }, []);\r\n\r\n\r\n// return (\r\n//   <div style={{ position: 'relative', display: 'inline-block' }}>\r\n//     <div\r\n//       style={{\r\n//         position: 'absolute',\r\n//         display: 'flex',\r\n//         width: '100%',\r\n//         alignItems: 'center',\r\n//         padding: '20px',\r\n//       }}\r\n//     >\r\n//       {/* Player Health Bar */}\r\n//       <div style={{ position: 'relative', height: '30px', width: '100%', display: 'flex', justifyContent: 'flex-end' }}>\r\n//         <div style={{ backgroundColor: 'yellow', height: '30px', width: '100%' }}></div>\r\n//         <div\r\n//           id=\"playerHealth\"\r\n//           style={{\r\n//             position: 'absolute',\r\n//             background: 'blue',\r\n//             top: 0,\r\n//             right: 0,\r\n//             bottom: 0,\r\n//             width: '100%',\r\n//           }}\r\n//         ></div>\r\n//       </div>\r\n\r\n//       {/* Timer */}\r\n//       <div\r\n//       id = \"timer\"\r\n//        style={{ \r\n//         backgroundColor: 'red', \r\n//         width: '100px', \r\n//         height: '100px', \r\n//         flexShrink: 0,\r\n//         display: 'flex',\r\n//         alignItems: 'center',\r\n//         justifyContent: 'center',\r\n//         }}\r\n//       >\r\n//         {timer}\r\n//       </div>\r\n\r\n//       {/* Enemy Health Bar */}\r\n//       <div style={{ position: 'relative', height: '30px', width: '100%' }}>\r\n//         <div style={{ backgroundColor: 'yellow', height: '30px' }}></div>\r\n//         <div\r\n//           id=\"enemyHealth\"\r\n//           style={{\r\n//             position: 'absolute',\r\n//             background: 'blue',\r\n//             top: 0,\r\n//             right: 0,\r\n//             bottom: 0,\r\n//             left: 0,\r\n//           }}\r\n//         ></div>\r\n//       </div>\r\n//       <div></div>\r\n//     </div>\r\n//     <div\r\n//     id=\"displayText\"\r\n//      style={{\r\n//       position: 'absolute', \r\n//       color: 'black',\r\n//       alignItems: 'center', \r\n//       justifyContent:'center',\r\n//       top: 0,\r\n//       right : 0,\r\n//       bottom : 0,\r\n//       left: 0,\r\n//       display: 'none'\r\n//       }}>Tie\r\n//       </div>\r\n//     <canvas ref={canvasRef} style={{ boxSizing: 'border-box' }} {...props} />\r\n//   </div>\r\n// );\r\n// };\r\n\r\n// export default Canvas;"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}