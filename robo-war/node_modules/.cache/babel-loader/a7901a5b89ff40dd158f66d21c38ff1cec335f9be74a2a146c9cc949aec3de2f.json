{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Meenal Jain\\\\Desktop\\\\robo_war\\\\robo-war\\\\src\\\\CanvasDrawing.js\",\n  _s = $RefreshSig$();\n// import React, { useRef, useEffect, useState } from 'react';\n// import './Components.css'; // Import your component-specific CSS file\n\n// import spriteImage from './Images/background.png';\n// import kenjiIdle from './Images/kenji/Idle.png';\n// import samuraiIdle from './Images/samuraiMack/Idle.png';\n\n// const initialPlayerState = {\n//   position: {\n//     x: 0,\n//     y: 0\n//   },\n//   velocity: {\n//     x: 0,\n//     y: 0\n//   },\n//   offset: {\n//     x: 0,\n//     y: 0\n//   },\n//   // imageSrc: './img/samuraiMack/Idle.png',\n//   imageSrc: samuraiIdle,\n//   framesMax: 8,\n//   scale: 2.5,\n//   offset: {\n//     x: 215,\n//     y: 157\n//   },\n//   sprites: {\n//     idle: {\n//       // imageSrc: './img/samuraiMack/Idle.png',\n//       imageSrc: samuraiIdle,\n//       framesMax: 8\n//     },\n//     // ... Add other sprite definitions here\n//   },\n//   attackBox: {\n//     offset: {\n//       x: 100,\n//       y: 50\n//     },\n//     width: 160,\n//     height: 50\n//   }\n// };\n// const initialEnemyState = {\n//   position: {\n//     x: 400,\n//     y: 100\n//   },\n//   velocity: {\n//     x: 0,\n//     y: 0\n//   },\n//   color: 'blue',\n//   offset: {\n//     x: -50,\n//     y: 0\n//   },\n//   // imageSrc: './img/kenji/Idle.png',\n//   imageSrc: kenjiIdle,\n//   framesMax: 4,\n//   scale: 2.5,\n//   offset: {\n//     x: 215,\n//     y: 167\n//   },\n//   sprites: {\n//     idle: {\n//       // imageSrc: './img/kenji/Idle.png',\n//       imageSrc: kenjiIdle,\n//       framesMax: 4\n//     },\n//     // ... Add other sprite definitions here\n//   },\n//   attackBox: {\n//     offset: {\n//       x: -170,\n//       y: 50\n//     },\n//     width: 170,\n//     height: 50\n//   }\n// };\n// function CanvasDrawing() {\n//   // Create a ref for the canvas element\n//   const canvasRef = useRef(null);\n//   const [player, setPlayer] = useState(initialPlayerState);\n//   const [enemy, setEnemy] = useState(initialEnemyState);\n//   const [keys, setKeys] = useState({\n//     a: {\n//       pressed: false\n//     },\n//     d: {\n//       pressed: false\n//     },\n//     ArrowRight: {\n//       pressed: false\n//     },\n//     ArrowLeft: {\n//       pressed: false\n//     }\n//   });\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     const gravity = 0.7;\n\n//     // Set canvas dimensions\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     // Use the spriteImage as the background\n//     const backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     // Once the image is loaded, draw it on the canvas\n//     backgroundImage.onload = () => {\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//     // Other drawing code here\n//     // ctx.fillStyle = 'blue';\n//     // ctx.fillRect(0, 0, canvas.width, canvas.height);\n// // Draw the sprite image\n// const playerImage = new Image();\n// // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\n// playerImage.src = kenjiIdle; \n// playerImage.onload = () => {\n//   // Draw the player image at the desired position (player.position.x, player.position.y)\n//   ctx.drawImage(playerImage, player.position.x, player.position.y);\n// };\n// };\n//     const handleKeyDown = (event) => {\n//       // Update the keys state based on the pressed key\n//       setKeys((prevKeys) => ({\n//         ...prevKeys,\n//         [event.key]: {\n//           pressed: true\n//         }\n//       }));\n//     };\n\n//     const handleKeyUp = (event) => {\n//       // Update the keys state when a key is released\n//       setKeys((prevKeys) => ({\n//         ...prevKeys,\n//         [event.key]: {\n//           pressed: false\n//         }\n//       }));\n//     };\n\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     // Cleanup (optional)\n//     return () => {\n//       // You can perform cleanup here if needed\n//     };\n//   }, []); // Empty dependency array to run only once\n\n//   return (\n//     <div>\n//       <canvas ref={canvasRef}></canvas>\n//     </div>\n//   );\n// }\n\n// export default CanvasDrawing;\n\n// import React, { useRef, useEffect, useState } from 'react';\n// import './Components.css'; // Import your component-specific CSS file\n\n// import spriteImage from './Images/background.png';\n// import kenjiIdle from './Images/kenji/Idle.png';\n// import samuraiIdle from './Images/samuraiMack/Idle.png';\n\n// const initialPlayerState = {\n//   position: {\n//     x: 0,\n//     y: 0\n//   },\n//   velocity: {\n//     x: 0,\n//     y: 0\n//   },\n//   scale: 2.5,\n// };\n\n// function CanvasDrawing() {\n//   const canvasRef = useRef(null);\n//   const [player, setPlayer] = useState(initialPlayerState);\n//   const [keys, setKeys] = useState({\n//         a: {\n//           pressed: false\n//         },\n//         d: {\n//           pressed: false\n//         },\n//         ArrowRight: {\n//           pressed: false\n//         },\n//         ArrowLeft: {\n//           pressed: false\n//         }\n//       });\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     const gravity = 0.7;\n\n//     // Set canvas dimensions\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     // Use the spriteImage as the background\n//     const backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     // Load the player images\n//     const kenjiImage = new Image();\n//     kenjiImage.src = kenjiIdle;\n\n//     const samuraiImage = new Image();\n//     samuraiImage.src = samuraiIdle;\n\n//     // Once the images are loaded, draw them on the canvas\n//     const drawCharacters = () => {\n//       ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas\n\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Draw the Kenji character\n//       ctx.drawImage(\n//         kenjiImage,\n//         player.position.x, // Adjust the position as needed\n//         player.position.y,\n//         kenjiImage.width * player.scale,\n//         kenjiImage.height * player.scale\n//       );\n\n//       // Draw the Samurai character\n//       ctx.drawImage(\n//         samuraiImage,\n//         player.position.x + 200, // Adjust the position as needed\n//         player.position.y,\n//         samuraiImage.width * player.scale,\n//         samuraiImage.height * player.scale\n//       );\n\n//       // Request the next animation frame\n//       // requestAnimationFrame(drawCharacters);\n//     };\n\n//     // Start the animation loop\n//     drawCharacters();\n//         const handleKeyDown = (event) => {\n//       // Update the keys state based on the pressed key\n//       setKeys((prevKeys) => ({\n//         ...prevKeys,\n//         [event.key]: {\n//           pressed: true\n//         }\n//       }));\n//     };\n\n//     const handleKeyUp = (event) => {\n//       // Update the keys state when a key is released\n//       setKeys((prevKeys) => ({\n//         ...prevKeys,\n//         [event.key]: {\n//           pressed: false\n//         }\n//       }));\n//     };\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     // Cleanup (optional)\n//     return () => {\n//       // Remove event listeners or do other cleanup if needed\n//     };\n//   }, []); // Empty dependency array to run only once\n\n//   return (\n//     <div>\n//       <canvas ref={canvasRef}></canvas>\n//     </div>\n//   );\n// }\n\n// export default CanvasDrawing;\n\nimport React, { useRef, useEffect, useState } from 'react';\nimport './Components.css';\nimport spriteImage from './Images/background.png'; // Load the single sprite sheet\nimport { AnimationFrame } from './AnimationFramenimationFrame'; // You might need a utility for handling animations\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialPlayerState = {\n  position: {\n    x: 0,\n    y: 0\n  },\n  velocity: {\n    x: 0,\n    y: 0\n  },\n  scale: 2.5\n};\n\n// Define frame dimensions and animation parameters\nconst kenjiFrameWidth = 64; // Width of a single frame in pixels\nconst kenjiFrameHeight = 64; // Height of a single frame in pixels\nconst kenjiTotalFrames = 8; // Total number of frames in Kenji's animation\nconst kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\n\nconst samuraiFrameWidth = 64; // Width of a single frame in pixels\nconst samuraiFrameHeight = 64; // Height of a single frame in pixels\nconst samuraiTotalFrames = 8; // Total number of frames in Samurai's animation\nconst samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\n\nfunction CanvasDrawing() {\n  _s();\n  const canvasRef = useRef(null);\n  const [player, setPlayer] = useState(initialPlayerState);\n  const [currentFrame, setCurrentFrame] = useState(0);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const gravity = 0.7;\n\n    // Set canvas dimensions\n    canvas.width = 1024;\n    canvas.height = 576;\n\n    // Use the spriteImage as the background\n    const backgroundImage = new Image();\n    backgroundImage.src = spriteImage;\n\n    // Create an animation frame object for each character\n    const kenjiAnimationFrame = new AnimationFrame({\n      image: backgroundImage,\n      frameWidth: kenjiFrameWidth,\n      frameHeight: kenjiFrameHeight,\n      totalFrames: kenjiTotalFrames,\n      animationSpeed: kenjiAnimationSpeed\n    });\n    const samuraiAnimationFrame = new AnimationFrame({\n      image: backgroundImage,\n      frameWidth: samuraiFrameWidth,\n      frameHeight: samuraiFrameHeight,\n      totalFrames: samuraiTotalFrames,\n      animationSpeed: samuraiAnimationSpeed\n    });\n\n    // Define key state for controlling characters\n    const keys = {\n      ArrowLeft: false,\n      ArrowRight: false,\n      Space: false\n    };\n\n    // Handle keydown event\n    const handleKeyDown = event => {\n      if (event.key === 'ArrowLeft') {\n        keys.ArrowLeft = true;\n      } else if (event.key === 'ArrowRight') {\n        keys.ArrowRight = true;\n      } else if (event.key === 'Space') {\n        keys.Space = true;\n      }\n    };\n\n    // Handle keyup event\n    const handleKeyUp = event => {\n      if (event.key === 'ArrowLeft') {\n        keys.ArrowLeft = false;\n      } else if (event.key === 'ArrowRight') {\n        keys.ArrowRight = false;\n      } else if (event.key === 'Space') {\n        keys.Space = false;\n      }\n    };\n\n    // Add event listeners for keydown and keyup\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    // Start the animation loop\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw the background image\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n      // Update the player's position based on keyboard input\n      if (keys.ArrowLeft) {\n        player.position.x -= player.velocity.x;\n      } else if (keys.ArrowRight) {\n        player.position.x += player.velocity.x;\n      }\n\n      // Draw Kenji character\n      kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\n\n      // Draw Samurai character\n      samuraiAnimationFrame.draw(ctx, player.position.x + 200, player.position.y);\n\n      // Update the current frame for each character's animation\n      setCurrentFrame(prevFrame => prevFrame + 1);\n      requestAnimationFrame(animate);\n    };\n    animate();\n\n    // Cleanup (optional)\n    return () => {\n      // Remove event listeners or do other cleanup if needed\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []); // Empty dependency array to run only once\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 434,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 433,\n    columnNumber: 5\n  }, this);\n}\n_s(CanvasDrawing, \"OaE9ZtnT96uiCQAWtN9X/n7tD0w=\");\n_c = CanvasDrawing;\nexport default CanvasDrawing;\nvar _c;\n$RefreshReg$(_c, \"CanvasDrawing\");","map":{"version":3,"names":["React","useRef","useEffect","useState","spriteImage","AnimationFrame","jsxDEV","_jsxDEV","initialPlayerState","position","x","y","velocity","scale","kenjiFrameWidth","kenjiFrameHeight","kenjiTotalFrames","kenjiAnimationSpeed","samuraiFrameWidth","samuraiFrameHeight","samuraiTotalFrames","samuraiAnimationSpeed","CanvasDrawing","_s","canvasRef","player","setPlayer","currentFrame","setCurrentFrame","canvas","current","ctx","getContext","gravity","width","height","backgroundImage","Image","src","kenjiAnimationFrame","image","frameWidth","frameHeight","totalFrames","animationSpeed","samuraiAnimationFrame","keys","ArrowLeft","ArrowRight","Space","handleKeyDown","event","key","handleKeyUp","window","addEventListener","animate","clearRect","drawImage","draw","prevFrame","requestAnimationFrame","removeEventListener","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/CanvasDrawing.js"],"sourcesContent":["// import React, { useRef, useEffect, useState } from 'react';\r\n// import './Components.css'; // Import your component-specific CSS file\r\n\r\n// import spriteImage from './Images/background.png';\r\n// import kenjiIdle from './Images/kenji/Idle.png';\r\n// import samuraiIdle from './Images/samuraiMack/Idle.png';\r\n\r\n// const initialPlayerState = {\r\n//   position: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   offset: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   // imageSrc: './img/samuraiMack/Idle.png',\r\n//   imageSrc: samuraiIdle,\r\n//   framesMax: 8,\r\n//   scale: 2.5,\r\n//   offset: {\r\n//     x: 215,\r\n//     y: 157\r\n//   },\r\n//   sprites: {\r\n//     idle: {\r\n//       // imageSrc: './img/samuraiMack/Idle.png',\r\n//       imageSrc: samuraiIdle,\r\n//       framesMax: 8\r\n//     },\r\n//     // ... Add other sprite definitions here\r\n//   },\r\n//   attackBox: {\r\n//     offset: {\r\n//       x: 100,\r\n//       y: 50\r\n//     },\r\n//     width: 160,\r\n//     height: 50\r\n//   }\r\n// };\r\n// const initialEnemyState = {\r\n//   position: {\r\n//     x: 400,\r\n//     y: 100\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   color: 'blue',\r\n//   offset: {\r\n//     x: -50,\r\n//     y: 0\r\n//   },\r\n//   // imageSrc: './img/kenji/Idle.png',\r\n//   imageSrc: kenjiIdle,\r\n//   framesMax: 4,\r\n//   scale: 2.5,\r\n//   offset: {\r\n//     x: 215,\r\n//     y: 167\r\n//   },\r\n//   sprites: {\r\n//     idle: {\r\n//       // imageSrc: './img/kenji/Idle.png',\r\n//       imageSrc: kenjiIdle,\r\n//       framesMax: 4\r\n//     },\r\n//     // ... Add other sprite definitions here\r\n//   },\r\n//   attackBox: {\r\n//     offset: {\r\n//       x: -170,\r\n//       y: 50\r\n//     },\r\n//     width: 170,\r\n//     height: 50\r\n//   }\r\n// };\r\n// function CanvasDrawing() {\r\n//   // Create a ref for the canvas element\r\n//   const canvasRef = useRef(null);\r\n//   const [player, setPlayer] = useState(initialPlayerState);\r\n//   const [enemy, setEnemy] = useState(initialEnemyState);\r\n//   const [keys, setKeys] = useState({\r\n//     a: {\r\n//       pressed: false\r\n//     },\r\n//     d: {\r\n//       pressed: false\r\n//     },\r\n//     ArrowRight: {\r\n//       pressed: false\r\n//     },\r\n//     ArrowLeft: {\r\n//       pressed: false\r\n//     }\r\n//   });\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     const gravity = 0.7;\r\n\r\n//     // Set canvas dimensions\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     // Use the spriteImage as the background\r\n//     const backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n    \r\n//     // Once the image is loaded, draw it on the canvas\r\n//     backgroundImage.onload = () => {\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n    \r\n\r\n//     // Other drawing code here\r\n//     // ctx.fillStyle = 'blue';\r\n//     // ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n// // Draw the sprite image\r\n// const playerImage = new Image();\r\n// // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\r\n// playerImage.src = kenjiIdle; \r\n// playerImage.onload = () => {\r\n//   // Draw the player image at the desired position (player.position.x, player.position.y)\r\n//   ctx.drawImage(playerImage, player.position.x, player.position.y);\r\n// };\r\n// };\r\n//     const handleKeyDown = (event) => {\r\n//       // Update the keys state based on the pressed key\r\n//       setKeys((prevKeys) => ({\r\n//         ...prevKeys,\r\n//         [event.key]: {\r\n//           pressed: true\r\n//         }\r\n//       }));\r\n//     };\r\n\r\n//     const handleKeyUp = (event) => {\r\n//       // Update the keys state when a key is released\r\n//       setKeys((prevKeys) => ({\r\n//         ...prevKeys,\r\n//         [event.key]: {\r\n//           pressed: false\r\n//         }\r\n//       }));\r\n//     };\r\n\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n    \r\n//     // Cleanup (optional)\r\n//     return () => {\r\n//       // You can perform cleanup here if needed\r\n//     };\r\n//   }, []); // Empty dependency array to run only once\r\n\r\n//   return (\r\n//     <div>\r\n//       <canvas ref={canvasRef}></canvas>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default CanvasDrawing;\r\n\r\n\r\n\r\n// import React, { useRef, useEffect, useState } from 'react';\r\n// import './Components.css'; // Import your component-specific CSS file\r\n\r\n// import spriteImage from './Images/background.png';\r\n// import kenjiIdle from './Images/kenji/Idle.png';\r\n// import samuraiIdle from './Images/samuraiMack/Idle.png';\r\n\r\n// const initialPlayerState = {\r\n//   position: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   scale: 2.5,\r\n// };\r\n\r\n// function CanvasDrawing() {\r\n//   const canvasRef = useRef(null);\r\n//   const [player, setPlayer] = useState(initialPlayerState);\r\n//   const [keys, setKeys] = useState({\r\n//         a: {\r\n//           pressed: false\r\n//         },\r\n//         d: {\r\n//           pressed: false\r\n//         },\r\n//         ArrowRight: {\r\n//           pressed: false\r\n//         },\r\n//         ArrowLeft: {\r\n//           pressed: false\r\n//         }\r\n//       });\r\n\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     const gravity = 0.7;\r\n\r\n//     // Set canvas dimensions\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     // Use the spriteImage as the background\r\n//     const backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n\r\n//     // Load the player images\r\n//     const kenjiImage = new Image();\r\n//     kenjiImage.src = kenjiIdle;\r\n\r\n//     const samuraiImage = new Image();\r\n//     samuraiImage.src = samuraiIdle;\r\n    \r\n//     // Once the images are loaded, draw them on the canvas\r\n//     const drawCharacters = () => {\r\n//       ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas\r\n\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the Kenji character\r\n//       ctx.drawImage(\r\n//         kenjiImage,\r\n//         player.position.x, // Adjust the position as needed\r\n//         player.position.y,\r\n//         kenjiImage.width * player.scale,\r\n//         kenjiImage.height * player.scale\r\n//       );\r\n\r\n//       // Draw the Samurai character\r\n//       ctx.drawImage(\r\n//         samuraiImage,\r\n//         player.position.x + 200, // Adjust the position as needed\r\n//         player.position.y,\r\n//         samuraiImage.width * player.scale,\r\n//         samuraiImage.height * player.scale\r\n//       );\r\n\r\n//       // Request the next animation frame\r\n//       // requestAnimationFrame(drawCharacters);\r\n//     };\r\n\r\n//     // Start the animation loop\r\n//     drawCharacters();\r\n//         const handleKeyDown = (event) => {\r\n//       // Update the keys state based on the pressed key\r\n//       setKeys((prevKeys) => ({\r\n//         ...prevKeys,\r\n//         [event.key]: {\r\n//           pressed: true\r\n//         }\r\n//       }));\r\n//     };\r\n\r\n//     const handleKeyUp = (event) => {\r\n//       // Update the keys state when a key is released\r\n//       setKeys((prevKeys) => ({\r\n//         ...prevKeys,\r\n//         [event.key]: {\r\n//           pressed: false\r\n//         }\r\n//       }));\r\n//     };\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n    \r\n//     // Cleanup (optional)\r\n//     return () => {\r\n//       // Remove event listeners or do other cleanup if needed\r\n//     };\r\n//   }, []); // Empty dependency array to run only once\r\n\r\n//   return (\r\n//     <div>\r\n//       <canvas ref={canvasRef}></canvas>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default CanvasDrawing;\r\n\r\nimport React, { useRef, useEffect, useState } from 'react';\r\nimport './Components.css';\r\n\r\nimport spriteImage from './Images/background.png'; // Load the single sprite sheet\r\nimport { AnimationFrame } from './AnimationFramenimationFrame'; // You might need a utility for handling animations\r\n\r\nconst initialPlayerState = {\r\n  position: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  velocity: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  scale: 2.5,\r\n};\r\n\r\n// Define frame dimensions and animation parameters\r\nconst kenjiFrameWidth = 64; // Width of a single frame in pixels\r\nconst kenjiFrameHeight = 64; // Height of a single frame in pixels\r\nconst kenjiTotalFrames = 8; // Total number of frames in Kenji's animation\r\nconst kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\r\n\r\nconst samuraiFrameWidth = 64; // Width of a single frame in pixels\r\nconst samuraiFrameHeight = 64; // Height of a single frame in pixels\r\nconst samuraiTotalFrames = 8; // Total number of frames in Samurai's animation\r\nconst samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\r\n\r\nfunction CanvasDrawing() {\r\n  const canvasRef = useRef(null);\r\n  const [player, setPlayer] = useState(initialPlayerState);\r\n  const [currentFrame, setCurrentFrame] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const gravity = 0.7;\r\n\r\n    // Set canvas dimensions\r\n    canvas.width = 1024;\r\n    canvas.height = 576;\r\n\r\n    // Use the spriteImage as the background\r\n    const backgroundImage = new Image();\r\n    backgroundImage.src = spriteImage;\r\n\r\n    // Create an animation frame object for each character\r\n    const kenjiAnimationFrame = new AnimationFrame({\r\n      image: backgroundImage,\r\n      frameWidth: kenjiFrameWidth,\r\n      frameHeight: kenjiFrameHeight,\r\n      totalFrames: kenjiTotalFrames,\r\n      animationSpeed: kenjiAnimationSpeed,\r\n    });\r\n\r\n    const samuraiAnimationFrame = new AnimationFrame({\r\n      image: backgroundImage,\r\n      frameWidth: samuraiFrameWidth,\r\n      frameHeight: samuraiFrameHeight,\r\n      totalFrames: samuraiTotalFrames,\r\n      animationSpeed: samuraiAnimationSpeed,\r\n    });\r\n\r\n    // Define key state for controlling characters\r\n    const keys = {\r\n      ArrowLeft: false,\r\n      ArrowRight: false,\r\n      Space: false,\r\n    };\r\n\r\n    // Handle keydown event\r\n    const handleKeyDown = (event) => {\r\n      if (event.key === 'ArrowLeft') {\r\n        keys.ArrowLeft = true;\r\n      } else if (event.key === 'ArrowRight') {\r\n        keys.ArrowRight = true;\r\n      } else if (event.key === 'Space') {\r\n        keys.Space = true;\r\n      }\r\n    };\r\n\r\n    // Handle keyup event\r\n    const handleKeyUp = (event) => {\r\n      if (event.key === 'ArrowLeft') {\r\n        keys.ArrowLeft = false;\r\n      } else if (event.key === 'ArrowRight') {\r\n        keys.ArrowRight = false;\r\n      } else if (event.key === 'Space') {\r\n        keys.Space = false;\r\n      }\r\n    };\r\n\r\n    // Add event listeners for keydown and keyup\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    // Start the animation loop\r\n    const animate = () => {\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      // Draw the background image\r\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n      // Update the player's position based on keyboard input\r\n      if (keys.ArrowLeft) {\r\n        player.position.x -= player.velocity.x;\r\n      } else if (keys.ArrowRight) {\r\n        player.position.x += player.velocity.x;\r\n      }\r\n\r\n      // Draw Kenji character\r\n      kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\r\n\r\n      // Draw Samurai character\r\n      samuraiAnimationFrame.draw(ctx, player.position.x + 200, player.position.y);\r\n\r\n      // Update the current frame for each character's animation\r\n      setCurrentFrame((prevFrame) => prevFrame + 1);\r\n\r\n      requestAnimationFrame(animate);\r\n    };\r\n\r\n    animate();\r\n\r\n    // Cleanup (optional)\r\n    return () => {\r\n      // Remove event listeners or do other cleanup if needed\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, []); // Empty dependency array to run only once\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={canvasRef}></canvas>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CanvasDrawing;\r\n\r\n\r\n"],"mappings":";;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}