{"ast":null,"code":"\n\n// import React, { useRef, useEffect } from 'react';\n// import spriteImage from './Images/background.png';\n\n// const Canvas = (props) => {\n//   const canvasRef = useRef(null);\n//   let player;\n//   let enemy;\n//   let backgroundImage;\n//   const keys = {\n//     a: {\n//       pressed: false,\n//     },\n//     d: {\n//       pressed: false,\n//     },\n//     ArrowRight: {\n//       pressed: false,\n//     },\n//     ArrowLeft: {\n//       pressed: false,\n//     },\n//   };\n//   let lastkey = ''; // Initialize lastkey with an empty string\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     player = new Sprite({\n//       position: { x: 150, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//     });\n\n//     enemy = new Sprite({\n//       position: { x: 450, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//       color: 'blue'\n//     });\n\n//     backgroundImage.onload = () => {\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Draw the initial sprites\n//       player.draw(ctx);\n//       enemy.draw(ctx);\n//     };\n\n//     // Event listeners\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     function handleKeyDown(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = true;\n//           lastkey = 'd';\n//           break;\n//         case 'a':\n//           keys.a.pressed = true;\n//           lastkey = 'a';\n//           break;\n//           case ' ':\n//             player.attack()  \n//             break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = true;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = true;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//       }\n//     }\n\n//     function handleKeyUp(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = false;\n//           break;\n//         case 'a':\n//           keys.a.pressed = false;\n//           break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = true;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = true;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//       }\n//     }\n//   }, []);\n\n//   const gravity = 0.007;\n\n//   class Sprite {\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\n//       this.position = position;\n//       this.velocity = velocity;\n//       this.height = 150;\n//       this.width = 50;\n//       this.attackbox = {\n//         position: {\n//           x:this.position.x,\n//           y:this.position.y\n//         },\n//         offset,\n\n//         width: 100 ,\n//         height: 50\n//       }\n//       this.isAttacking = '';\n//       this.color = color;\n//     }\n\n//     draw(ctx) {\n//       ctx.fillStyle = this.color;\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\n//       // attackbox\n//       // if (this.isAttacking) {\n\n//       ctx.fillStyle = 'green';\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\n//     }\n//   // }\n\n//     update(ctx) {\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\n//       this.attackbox.position.y = this.position.y;\n\n//       this.position.x += this.velocity.x;\n//       this.position.y += this.velocity.y;\n//       if (this.position.y + this.height >= ctx.height) {\n//         this.velocity.y = 0;\n//         this.position.y = ctx.height - this.height;\n//       } else {\n//         this.velocity.y += gravity;\n//       }\n//     }\n//       attack() {\n//         this.isAttacking = true\n//         setTimeout(() => {\n//           this.isAttacking = false\n//         }, 100\n//         )\n\n//     }\n//   }\n\n//   function animate() {\n//     const canvas = canvasRef.current;\n\n//      if (canvas && player && enemy) {\n//       const ctx = canvas.getContext('2d');\n\n//       // Clear the canvas\n//       ctx.fillStyle = 'black';\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Update and draw the sprites\n//       player.update(canvas);\n//       player.draw(ctx);\n\n//       enemy.update(canvas);\n//       enemy.draw(ctx);\n\n//       player.velocity.x = 0;\n//       enemy.velocity.x = 0;\n\n//       if (keys.a.pressed && lastkey === 'a') {\n//         player.velocity.x = -5;\n//       } else if (keys.d.pressed && lastkey === 'd') {\n//         player.velocity.x = 5;\n//       }\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\n//         enemy.velocity.x = -5;\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\n//         enemy.velocity.x = 5;\n//       }\n//       // detect for collision\n//       if (player.attackbox.position.x + player.attackbox.width >= \n//         enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width &&\n//         player.attackbox.position.y + player.attackbox.height >= enemy.position.y\n//         && player.attackbox.position.y <= enemy.position.y + enemy.height &&\n//         player.isAttacking) {\n//         console.log('go');\n//       }\n\n//     }\n\n//     window.requestAnimationFrame(animate);\n//   }\n\n//   useEffect(() => {\n//     animate(); // Start the animation loop after the initial render\n//   }, []);\n\n//   return <canvas ref={canvasRef} {...props} />;\n// };\n\n// export default Canvas;","map":{"version":3,"names":[],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/Canvas.jsx"],"sourcesContent":["\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import React, { useRef, useEffect } from 'react';\r\n// import spriteImage from './Images/background.png';\r\n\r\n// const Canvas = (props) => {\r\n//   const canvasRef = useRef(null);\r\n//   let player;\r\n//   let enemy;\r\n//   let backgroundImage;\r\n//   const keys = {\r\n//     a: {\r\n//       pressed: false,\r\n//     },\r\n//     d: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowRight: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowLeft: {\r\n//       pressed: false,\r\n//     },\r\n//   };\r\n//   let lastkey = ''; // Initialize lastkey with an empty string\r\n\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n\r\n//     player = new Sprite({\r\n//       position: { x: 150, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//     });\r\n\r\n//     enemy = new Sprite({\r\n//       position: { x: 450, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//       color: 'blue'\r\n//     });\r\n\r\n//     backgroundImage.onload = () => {\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the initial sprites\r\n//       player.draw(ctx);\r\n//       enemy.draw(ctx);\r\n//     };\r\n\r\n//     // Event listeners\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n\r\n//     function handleKeyDown(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = true;\r\n//           lastkey = 'd';\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = true;\r\n//           lastkey = 'a';\r\n//           break;\r\n//           case ' ':\r\n//             player.attack()  \r\n//             break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = true;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = true;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//       }\r\n//     }\r\n\r\n//     function handleKeyUp(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = false;\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = false;\r\n//           break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = true;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = true;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//       }\r\n//     }\r\n//   }, []);\r\n\r\n//   const gravity = 0.007;\r\n\r\n//   class Sprite {\r\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\r\n//       this.position = position;\r\n//       this.velocity = velocity;\r\n//       this.height = 150;\r\n//       this.width = 50;\r\n//       this.attackbox = {\r\n//         position: {\r\n//           x:this.position.x,\r\n//           y:this.position.y\r\n//         },\r\n//         offset,\r\n        \r\n//         width: 100 ,\r\n//         height: 50\r\n//       }\r\n//       this.isAttacking = '';\r\n//       this.color = color;\r\n//     }\r\n\r\n//     draw(ctx) {\r\n//       ctx.fillStyle = this.color;\r\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\r\n//       // attackbox\r\n//       // if (this.isAttacking) {\r\n\r\n      \r\n//       ctx.fillStyle = 'green';\r\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\r\n//     }\r\n//   // }\r\n\r\n//     update(ctx) {\r\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\r\n//       this.attackbox.position.y = this.position.y;\r\n\r\n//       this.position.x += this.velocity.x;\r\n//       this.position.y += this.velocity.y;\r\n//       if (this.position.y + this.height >= ctx.height) {\r\n//         this.velocity.y = 0;\r\n//         this.position.y = ctx.height - this.height;\r\n//       } else {\r\n//         this.velocity.y += gravity;\r\n//       }\r\n//     }\r\n//       attack() {\r\n//         this.isAttacking = true\r\n//         setTimeout(() => {\r\n//           this.isAttacking = false\r\n//         }, 100\r\n//         )\r\n        \r\n      \r\n//     }\r\n//   }\r\n\r\n//   function animate() {\r\n//     const canvas = canvasRef.current;\r\n\r\n//      if (canvas && player && enemy) {\r\n//       const ctx = canvas.getContext('2d');\r\n\r\n//       // Clear the canvas\r\n//       ctx.fillStyle = 'black';\r\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Update and draw the sprites\r\n//       player.update(canvas);\r\n//       player.draw(ctx);\r\n\r\n//       enemy.update(canvas);\r\n//       enemy.draw(ctx);\r\n\r\n//       player.velocity.x = 0;\r\n//       enemy.velocity.x = 0;\r\n\r\n\r\n//       if (keys.a.pressed && lastkey === 'a') {\r\n//         player.velocity.x = -5;\r\n//       } else if (keys.d.pressed && lastkey === 'd') {\r\n//         player.velocity.x = 5;\r\n//       }\r\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\r\n//         enemy.velocity.x = -5;\r\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\r\n//         enemy.velocity.x = 5;\r\n//       }\r\n//       // detect for collision\r\n//       if (player.attackbox.position.x + player.attackbox.width >= \r\n//         enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width &&\r\n//         player.attackbox.position.y + player.attackbox.height >= enemy.position.y\r\n//         && player.attackbox.position.y <= enemy.position.y + enemy.height &&\r\n//         player.isAttacking) {\r\n//         console.log('go');\r\n//       }\r\n      \r\n//     }\r\n\r\n//     window.requestAnimationFrame(animate);\r\n//   }\r\n\r\n//   useEffect(() => {\r\n//     animate(); // Start the animation loop after the initial render\r\n//   }, []);\r\n\r\n//   return <canvas ref={canvasRef} {...props} />;\r\n// };\r\n\r\n// export default Canvas;"],"mappings":";;AAeA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}