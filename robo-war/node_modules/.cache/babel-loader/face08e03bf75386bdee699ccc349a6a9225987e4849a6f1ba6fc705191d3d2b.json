{"ast":null,"code":"// import React, { useEffect, useRef } from \"react\";\n\n// // Define your Sprite and Fighter classes here (including their methods) or import them if they are in separate files.\n// // Sprite class definition\n// class Sprite {\n//   constructor(options) {\n//     // Initialize properties for the Sprite\n//     this.position = options.position || { x: 0, y: 0 };\n//     this.imageSrc = options.imageSrc || ''; // Path to image\n//     this.scale = options.scale || 1;\n//     this.framesMax = options.framesMax || 1;\n//     // Add other properties as needed\n\n//     // Load and initialize the image\n//     this.image = new Image();\n//     this.image.src = this.imageSrc;\n\n//     // Initialize other properties and methods\n\n//     // Load the image (you can add an event listener for 'load' to ensure it's loaded before rendering)\n//     this.image.onload = () => {\n//       // Image is loaded, you can set up any additional initialization here\n//     };\n//   }\n\n//   // Define methods for the Sprite class\n//   update() {\n//     // Update the position, animation, or any other logic for the sprite\n//     // ...\n\n//     // Render the sprite on the canvas\n//     // You can use ctx.drawImage to draw the image on the canvas\n//     // Example: ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.scale, this.image.height * this.scale);\n//   }\n// }\n\n// // Fighter class definition (extends Sprite)\n// class Fighter extends Sprite {\n//   constructor(options) {\n//     super(options); // Call the constructor of the parent class (Sprite)\n\n//     // Initialize properties specific to Fighter class\n//     this.velocity = options.velocity || { x: 0, y: 0 };\n//     this.isAttacking = false;\n//     this.health = 100;\n//     // Add other properties as needed\n\n//     // Initialize other properties and methods\n//     // ...\n//   }\n\n//   // Define methods for the Fighter class\n//   attack() {\n//     // Implement attack logic\n//     // ...\n\n//     // Set this.isAttacking to true during attack animation\n//     this.isAttacking = true;\n//   }\n\n//   takeHit() {\n//     // Implement logic for taking damage\n//     // ...\n\n//     // Update health and play hit animation\n//     this.health -= 10; // Adjust this based on your game's mechanics\n//   }\n\n//   // Add other methods for Fighter class\n//   // ...\n// }\n\n// // useEffect(() => {\n// //   const canvas = canvasRef.current;\n// //   if (!canvas) {\n// //       return; // Exit early if canvas is null\n// //   }\n\n// //   const ctx = canvas.getContext(\"2d\");\n\n// //   // Rest of your code...\n\n// // }, []);\n\n// const FightingGame = () => {\n//   const canvasRef = useRef(null);\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext(\"2d\");\n\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//     const gravity = 0.7;\n\n// const background = new Sprite({\n//   position: {\n//     x: 0,\n//     y: 0\n//   },\n//   imageSrc: './img/background.png'\n// })\n// const shop = new Sprite({\n//   position: {\n//     x: 650,\n//     y: 128\n//   },\n//   imageSrc: './img/shop.png',\n//   scale: 2.75,\n//   framesMax: 6\n// })\n\n// const player = new Fighter({\n//   position: {\n//     x: 0,\n//     y: 0\n//   },\n//   velocity: {\n//     x: 0,\n//     y: 0\n//   },\n//   offset: {\n//     x: 0,\n//     y: 0\n//   },\n//   imageSrc: './img/samuraiMack/Idle.png',\n//   framesMax: 8,\n//   scale: 2.5,\n//   offset: {\n//     x: 215,\n//     y: 157\n//   },\n// })\n\n// const enemy = new Fighter({\n//   position: {\n//     x: 400,\n//     y: 100\n//   },\n//   velocity: {\n//     x: 0,\n//     y: 0\n//   },\n//   color: 'blue',\n//   offset: {\n//     x: -50,\n//     y: 0\n//   },\n//   imageSrc: './img/kenji/Idle.png',\n//   framesMax: 4,\n//   scale: 2.5,\n//   offset: {\n//     x: 215,\n//     y: 167\n//   },\n// })\n\n// const keys = {\n//   a: {\n//     pressed: false\n//   },\n//   d: {\n//     pressed: false\n//   },\n//   ArrowRight: {\n//     pressed: false\n//   },\n//   ArrowLeft: {\n//     pressed: false\n//   }\n// }\n\n// function rectangularCollision({rectangle1 , rectangle2}) {\n//     return (\n//         rectangle1.attackBox.position.x + rectangle1.attackBox.width >=\n//             rectangle2.position.x && \n//         rectangle1.attackBox.position.x <=\n//             rectangle2.position.x + rectangle2.width &&\n//         rectangle1.attackBox.position.y + rectangle1.attackBox.height >= \n//             rectangle2.position.y\n//         && rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height\n//     )\n// }\n\n// // function determineWinner({player, enemy, timerId}) {\n// //     clearTimeout(timerId)\n// //     document.querySelector('#displayText').style.display = 'flex'\n// //     if(player.health === enemy.health) {\n// //         document.querySelector('#displayText').innerHTML = 'Tie'\n// //     }else if (player.health > enemy.health) {\n// //         document.querySelector('#displayText').innerHTML = 'Player 1 Wins'\n// //     }else if (player.health < enemy.health) {\n// //         document.querySelector('#displayText').innerHTML = 'Player 2 Wins'\n// //     }\n// // }\n\n// let timer = 60\n// let timerId\n// function decreaseTimer() {\n//     if(timer>0) {\n//         timerId = setTimeout(decreaseTimer, 1000);\n//         timer--;\n//         const timerElement = document.querySelector('#timer')\n//         // .innerHTML = timer;\n\n//         if (timerElement) {\n//           timerElement.innerHTML = timer;\n//       }\n//     }\n\n//     if (timer === 0) {\n//         determineWinner({player, enemy, timerId})\n//     }\n// }\n\n// function determineWinner({ player, enemy, timerId }) {\n//   clearTimeout(timerId);\n//   const displayTextElement = document.querySelector('#displayText');\n//   if (displayTextElement) {\n//       displayTextElement.style.display = 'flex';\n//       if (player.health === enemy.health) {\n//           displayTextElement.innerHTML = 'Tie';\n//       } else if (player.health > enemy.health) {\n//           displayTextElement.innerHTML = 'Player 1 Wins';\n//       } else if (player.health < enemy.health) {\n//           displayTextElement.innerHTML = 'Player 2 Wins';\n//       }\n//   }\n// }\n\n// decreaseTimer()\n\n// export { Sprite, Fighter };\n\n// // const FightingGame = () => {\n// //   const canvasRef = useRef(null);\n\n// //   useEffect(() => {\n// //     const canvas = canvasRef.current;\n// //     const ctx = canvas.getContext(\"2d\");\n\n// //     canvas.width = 1024;\n// //     canvas.height = 576;\n\n// //     ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n// //     const gravity = 0.7;\n\n//     // Define your background, shop, player, enemy, keys, and other game objects here.\n//     // ...\n\n//     // Your existing game loop (animate) can also be moved here\n//     function animate() {\n//       window.requestAnimationFrame(animate);\n//       ctx.fillStyle = \"black\";\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//       // Add your game update and rendering logic here\n//       // ...\n\n//       // Don't forget to clear the canvas before rendering\n//       ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n//       // Render your objects here\n//       background.update();\n//       shop.update();\n//       ctx.fillStyle = \"rgba(255, 255, 255, 0.15)\";\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\n//       player.update();\n//       enemy.update();\n\n//       // Rest of your game logic goes here\n//       // ...\n//         player.velocity.x = 0\n//         enemy.velocity.x = 0\n\n//       // player movement\n\n//     if (keys.a.pressed && player.lastKey === 'a') {\n//     player.velocity.x = -5\n//     player.switchSprite('run')\n//   } else if (keys.d.pressed && player.lastKey === 'd') {\n//     player.velocity.x = 5\n//     player.switchSprite('run')\n//   } else {\n//     player.switchSprite('idle')\n//   }\n\n//   // jumping\n//   if (player.velocity.y < 0) {\n//     player.switchSprite('jump')\n//   } else if (player.velocity.y > 0) {\n//     player.switchSprite('fall')\n//   }\n\n//   // Enemy movement\n//   if (keys.ArrowLeft.pressed && enemy.lastKey === 'ArrowLeft') {\n//     enemy.velocity.x = -5\n//     enemy.switchSprite('run')\n//   } else if (keys.ArrowRight.pressed && enemy.lastKey === 'ArrowRight') {\n//     enemy.velocity.x = 5\n//     enemy.switchSprite('run')\n//   } else {\n//     enemy.switchSprite('idle')\n//   }\n\n//   // jumping\n//   if (enemy.velocity.y < 0) {\n//     enemy.switchSprite('jump')\n//   } else if (enemy.velocity.y > 0) {\n//     enemy.switchSprite('fall')\n//   }\n\n//       // Your collision detection and other game mechanics\n//       // ...\n//       //  detect for collision & enemy gets hit\n//   // if (\n//   //   rectangularCollision({\n//   //     rectangle1: player,\n//   //     rectangle2: enemy\n//   //   }) &&\n//   //   player.isAttacking &&\n//   //   player.framesCurrent === 4\n//   // ) {\n//   //   enemy.takeHit()\n//   //   player.isAttacking = false\n\n//   //   gsap.to('#enemyHealth', {\n//   //     width: enemy.health + '%'\n//   //   })\n//   // }\n\n//       // End game based on health or other conditions\n//       // ...\n//         // end game based on health\n//   if (enemy.health <= 0 || player.health <= 0) {\n//     determineWinner({ player, enemy, timerId })\n//   }\n\n//       // Handle other game events and mechanics\n//       // ...\n//     }\n\n//     animate();\n\n//     // Event listeners can be added here\n//     window.addEventListener(\"keydown\", (event) => {\n//       // Your keydown event handling logic\n//         if (!player.dead) {\n//     switch (event.key) {\n//       case 'd':\n//         keys.d.pressed = true\n//         player.lastKey = 'd'\n//         break\n//       case 'a':\n//         keys.a.pressed = true\n//         player.lastKey = 'a'\n//         break\n//       case 'w':\n//         player.velocity.y = -20\n//         break\n//       case ' ':\n//         player.attack()\n//         break\n//     }\n//   }\n\n//   if (!enemy.dead) {\n//     switch (event.key) {\n//       case 'ArrowRight':\n//         keys.ArrowRight.pressed = true\n//         enemy.lastKey = 'ArrowRight'\n//         break\n//       case 'ArrowLeft':\n//         keys.ArrowLeft.pressed = true\n//         enemy.lastKey = 'ArrowLeft'\n//         break\n//       case 'ArrowUp':\n//         enemy.velocity.y = -20\n//         break\n//       case 'ArrowDown':\n//         enemy.attack()\n\n//         break\n//     }\n//   }\n//     });\n\n//     window.addEventListener(\"keyup\", (event) => {\n//       // Your keyup event handling logic\n//       // ...\n//         switch (event.key) {\n//     case 'd':\n//       keys.d.pressed = false\n//       break\n//     case 'a':\n//       keys.a.pressed = false\n//       break\n//   }\n\n//   // enemy keys\n//   switch (event.key) {\n//     case 'ArrowRight':\n//       keys.ArrowRight.pressed = false\n//       break\n//     case 'ArrowLeft':\n//       keys.ArrowLeft.pressed = false\n//       break\n//   }\n//     });\n\n//     // Don't forget to remove event listeners on component unmount\n//     // return () => {\n//     //   window.removeEventListener(\"keydown\", handleKeyDown);\n//     //   window.removeEventListener(\"keyup\", handleKeyUp);\n//     // };\n//   }, []);\n\n//   return <canvas ref={canvasRef}></canvas>;\n//   // <canvas ref={canvasRef}></canvas>\n// };\n\n// export default FightingGame;","map":{"version":3,"names":[],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/FightingGame.jsx"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\r\n\r\n\r\n// // Define your Sprite and Fighter classes here (including their methods) or import them if they are in separate files.\r\n// // Sprite class definition\r\n// class Sprite {\r\n//   constructor(options) {\r\n//     // Initialize properties for the Sprite\r\n//     this.position = options.position || { x: 0, y: 0 };\r\n//     this.imageSrc = options.imageSrc || ''; // Path to image\r\n//     this.scale = options.scale || 1;\r\n//     this.framesMax = options.framesMax || 1;\r\n//     // Add other properties as needed\r\n    \r\n//     // Load and initialize the image\r\n//     this.image = new Image();\r\n//     this.image.src = this.imageSrc;\r\n    \r\n//     // Initialize other properties and methods\r\n \r\n\r\n//     // Load the image (you can add an event listener for 'load' to ensure it's loaded before rendering)\r\n//     this.image.onload = () => {\r\n//       // Image is loaded, you can set up any additional initialization here\r\n//     };\r\n//   }\r\n\r\n//   // Define methods for the Sprite class\r\n//   update() {\r\n//     // Update the position, animation, or any other logic for the sprite\r\n//     // ...\r\n\r\n//     // Render the sprite on the canvas\r\n//     // You can use ctx.drawImage to draw the image on the canvas\r\n//     // Example: ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.scale, this.image.height * this.scale);\r\n//   }\r\n// }\r\n\r\n// // Fighter class definition (extends Sprite)\r\n// class Fighter extends Sprite {\r\n//   constructor(options) {\r\n//     super(options); // Call the constructor of the parent class (Sprite)\r\n    \r\n//     // Initialize properties specific to Fighter class\r\n//     this.velocity = options.velocity || { x: 0, y: 0 };\r\n//     this.isAttacking = false;\r\n//     this.health = 100;\r\n//     // Add other properties as needed\r\n    \r\n//     // Initialize other properties and methods\r\n//     // ...\r\n//   }\r\n\r\n//   // Define methods for the Fighter class\r\n//   attack() {\r\n//     // Implement attack logic\r\n//     // ...\r\n\r\n//     // Set this.isAttacking to true during attack animation\r\n//     this.isAttacking = true;\r\n//   }\r\n\r\n//   takeHit() {\r\n//     // Implement logic for taking damage\r\n//     // ...\r\n\r\n//     // Update health and play hit animation\r\n//     this.health -= 10; // Adjust this based on your game's mechanics\r\n//   }\r\n\r\n//   // Add other methods for Fighter class\r\n//   // ...\r\n// }\r\n\r\n// // useEffect(() => {\r\n// //   const canvas = canvasRef.current;\r\n// //   if (!canvas) {\r\n// //       return; // Exit early if canvas is null\r\n// //   }\r\n  \r\n// //   const ctx = canvas.getContext(\"2d\");\r\n\r\n// //   // Rest of your code...\r\n  \r\n// // }, []);\r\n\r\n\r\n// const FightingGame = () => {\r\n//   const canvasRef = useRef(null);\r\n\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext(\"2d\");\r\n\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n//     const gravity = 0.7;\r\n\r\n// const background = new Sprite({\r\n//   position: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   imageSrc: './img/background.png'\r\n// })\r\n// const shop = new Sprite({\r\n//   position: {\r\n//     x: 650,\r\n//     y: 128\r\n//   },\r\n//   imageSrc: './img/shop.png',\r\n//   scale: 2.75,\r\n//   framesMax: 6\r\n// })\r\n\r\n// const player = new Fighter({\r\n//   position: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   offset: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   imageSrc: './img/samuraiMack/Idle.png',\r\n//   framesMax: 8,\r\n//   scale: 2.5,\r\n//   offset: {\r\n//     x: 215,\r\n//     y: 157\r\n//   },\r\n// })\r\n\r\n// const enemy = new Fighter({\r\n//   position: {\r\n//     x: 400,\r\n//     y: 100\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 0\r\n//   },\r\n//   color: 'blue',\r\n//   offset: {\r\n//     x: -50,\r\n//     y: 0\r\n//   },\r\n//   imageSrc: './img/kenji/Idle.png',\r\n//   framesMax: 4,\r\n//   scale: 2.5,\r\n//   offset: {\r\n//     x: 215,\r\n//     y: 167\r\n//   },\r\n// })\r\n\r\n// const keys = {\r\n//   a: {\r\n//     pressed: false\r\n//   },\r\n//   d: {\r\n//     pressed: false\r\n//   },\r\n//   ArrowRight: {\r\n//     pressed: false\r\n//   },\r\n//   ArrowLeft: {\r\n//     pressed: false\r\n//   }\r\n// }\r\n\r\n// function rectangularCollision({rectangle1 , rectangle2}) {\r\n//     return (\r\n//         rectangle1.attackBox.position.x + rectangle1.attackBox.width >=\r\n//             rectangle2.position.x && \r\n//         rectangle1.attackBox.position.x <=\r\n//             rectangle2.position.x + rectangle2.width &&\r\n//         rectangle1.attackBox.position.y + rectangle1.attackBox.height >= \r\n//             rectangle2.position.y\r\n//         && rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height\r\n//     )\r\n// }\r\n\r\n// // function determineWinner({player, enemy, timerId}) {\r\n// //     clearTimeout(timerId)\r\n// //     document.querySelector('#displayText').style.display = 'flex'\r\n// //     if(player.health === enemy.health) {\r\n// //         document.querySelector('#displayText').innerHTML = 'Tie'\r\n// //     }else if (player.health > enemy.health) {\r\n// //         document.querySelector('#displayText').innerHTML = 'Player 1 Wins'\r\n// //     }else if (player.health < enemy.health) {\r\n// //         document.querySelector('#displayText').innerHTML = 'Player 2 Wins'\r\n// //     }\r\n// // }\r\n\r\n// let timer = 60\r\n// let timerId\r\n// function decreaseTimer() {\r\n//     if(timer>0) {\r\n//         timerId = setTimeout(decreaseTimer, 1000);\r\n//         timer--;\r\n//         const timerElement = document.querySelector('#timer')\r\n//         // .innerHTML = timer;\r\n\r\n//         if (timerElement) {\r\n//           timerElement.innerHTML = timer;\r\n//       }\r\n//     }\r\n\r\n//     if (timer === 0) {\r\n//         determineWinner({player, enemy, timerId})\r\n//     }\r\n// }\r\n\r\n// function determineWinner({ player, enemy, timerId }) {\r\n//   clearTimeout(timerId);\r\n//   const displayTextElement = document.querySelector('#displayText');\r\n//   if (displayTextElement) {\r\n//       displayTextElement.style.display = 'flex';\r\n//       if (player.health === enemy.health) {\r\n//           displayTextElement.innerHTML = 'Tie';\r\n//       } else if (player.health > enemy.health) {\r\n//           displayTextElement.innerHTML = 'Player 1 Wins';\r\n//       } else if (player.health < enemy.health) {\r\n//           displayTextElement.innerHTML = 'Player 2 Wins';\r\n//       }\r\n//   }\r\n// }\r\n\r\n// decreaseTimer()\r\n\r\n\r\n// export { Sprite, Fighter };\r\n\r\n\r\n// // const FightingGame = () => {\r\n// //   const canvasRef = useRef(null);\r\n\r\n// //   useEffect(() => {\r\n// //     const canvas = canvasRef.current;\r\n// //     const ctx = canvas.getContext(\"2d\");\r\n\r\n// //     canvas.width = 1024;\r\n// //     canvas.height = 576;\r\n\r\n// //     ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n// //     const gravity = 0.7;\r\n\r\n//     // Define your background, shop, player, enemy, keys, and other game objects here.\r\n//     // ...\r\n\r\n//     // Your existing game loop (animate) can also be moved here\r\n//     function animate() {\r\n//       window.requestAnimationFrame(animate);\r\n//       ctx.fillStyle = \"black\";\r\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Add your game update and rendering logic here\r\n//       // ...\r\n\r\n//       // Don't forget to clear the canvas before rendering\r\n//       ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Render your objects here\r\n//       background.update();\r\n//       shop.update();\r\n//       ctx.fillStyle = \"rgba(255, 255, 255, 0.15)\";\r\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n//       player.update();\r\n//       enemy.update();\r\n\r\n//       // Rest of your game logic goes here\r\n//       // ...\r\n//         player.velocity.x = 0\r\n//         enemy.velocity.x = 0\r\n      \r\n//       // player movement\r\n      \r\n//     if (keys.a.pressed && player.lastKey === 'a') {\r\n//     player.velocity.x = -5\r\n//     player.switchSprite('run')\r\n//   } else if (keys.d.pressed && player.lastKey === 'd') {\r\n//     player.velocity.x = 5\r\n//     player.switchSprite('run')\r\n//   } else {\r\n//     player.switchSprite('idle')\r\n//   }\r\n\r\n//   // jumping\r\n//   if (player.velocity.y < 0) {\r\n//     player.switchSprite('jump')\r\n//   } else if (player.velocity.y > 0) {\r\n//     player.switchSprite('fall')\r\n//   }\r\n\r\n//   // Enemy movement\r\n//   if (keys.ArrowLeft.pressed && enemy.lastKey === 'ArrowLeft') {\r\n//     enemy.velocity.x = -5\r\n//     enemy.switchSprite('run')\r\n//   } else if (keys.ArrowRight.pressed && enemy.lastKey === 'ArrowRight') {\r\n//     enemy.velocity.x = 5\r\n//     enemy.switchSprite('run')\r\n//   } else {\r\n//     enemy.switchSprite('idle')\r\n//   }\r\n\r\n//   // jumping\r\n//   if (enemy.velocity.y < 0) {\r\n//     enemy.switchSprite('jump')\r\n//   } else if (enemy.velocity.y > 0) {\r\n//     enemy.switchSprite('fall')\r\n//   }\r\n\r\n//       // Your collision detection and other game mechanics\r\n//       // ...\r\n//       //  detect for collision & enemy gets hit\r\n//   // if (\r\n//   //   rectangularCollision({\r\n//   //     rectangle1: player,\r\n//   //     rectangle2: enemy\r\n//   //   }) &&\r\n//   //   player.isAttacking &&\r\n//   //   player.framesCurrent === 4\r\n//   // ) {\r\n//   //   enemy.takeHit()\r\n//   //   player.isAttacking = false\r\n\r\n//   //   gsap.to('#enemyHealth', {\r\n//   //     width: enemy.health + '%'\r\n//   //   })\r\n//   // }\r\n\r\n//       // End game based on health or other conditions\r\n//       // ...\r\n//         // end game based on health\r\n//   if (enemy.health <= 0 || player.health <= 0) {\r\n//     determineWinner({ player, enemy, timerId })\r\n//   }\r\n\r\n\r\n//       // Handle other game events and mechanics\r\n//       // ...\r\n//     }\r\n\r\n//     animate();\r\n\r\n//     // Event listeners can be added here\r\n//     window.addEventListener(\"keydown\", (event) => {\r\n//       // Your keydown event handling logic\r\n//         if (!player.dead) {\r\n//     switch (event.key) {\r\n//       case 'd':\r\n//         keys.d.pressed = true\r\n//         player.lastKey = 'd'\r\n//         break\r\n//       case 'a':\r\n//         keys.a.pressed = true\r\n//         player.lastKey = 'a'\r\n//         break\r\n//       case 'w':\r\n//         player.velocity.y = -20\r\n//         break\r\n//       case ' ':\r\n//         player.attack()\r\n//         break\r\n//     }\r\n//   }\r\n\r\n//   if (!enemy.dead) {\r\n//     switch (event.key) {\r\n//       case 'ArrowRight':\r\n//         keys.ArrowRight.pressed = true\r\n//         enemy.lastKey = 'ArrowRight'\r\n//         break\r\n//       case 'ArrowLeft':\r\n//         keys.ArrowLeft.pressed = true\r\n//         enemy.lastKey = 'ArrowLeft'\r\n//         break\r\n//       case 'ArrowUp':\r\n//         enemy.velocity.y = -20\r\n//         break\r\n//       case 'ArrowDown':\r\n//         enemy.attack()\r\n\r\n//         break\r\n//     }\r\n//   }\r\n//     });\r\n\r\n//     window.addEventListener(\"keyup\", (event) => {\r\n//       // Your keyup event handling logic\r\n//       // ...\r\n//         switch (event.key) {\r\n//     case 'd':\r\n//       keys.d.pressed = false\r\n//       break\r\n//     case 'a':\r\n//       keys.a.pressed = false\r\n//       break\r\n//   }\r\n\r\n//   // enemy keys\r\n//   switch (event.key) {\r\n//     case 'ArrowRight':\r\n//       keys.ArrowRight.pressed = false\r\n//       break\r\n//     case 'ArrowLeft':\r\n//       keys.ArrowLeft.pressed = false\r\n//       break\r\n//   }\r\n//     });\r\n\r\n//     // Don't forget to remove event listeners on component unmount\r\n//     // return () => {\r\n//     //   window.removeEventListener(\"keydown\", handleKeyDown);\r\n//     //   window.removeEventListener(\"keyup\", handleKeyUp);\r\n//     // };\r\n//   }, []);\r\n\r\n//   return <canvas ref={canvasRef}></canvas>;\r\n//   // <canvas ref={canvasRef}></canvas>\r\n// };\r\n\r\n// export default FightingGame;\r\n\r\n\r\n"],"mappings":"AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}