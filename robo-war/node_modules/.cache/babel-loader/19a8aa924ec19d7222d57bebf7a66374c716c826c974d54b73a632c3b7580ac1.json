{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Meenal Jain\\\\Desktop\\\\robo_war\\\\robo-war\\\\src\\\\Canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Canvas = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [player, setPlayer] = useState(null);\n  const [enemy, setEnemy] = useState(null);\n  const [keys, setKeys] = useState({\n    a: {\n      pressed: false\n    },\n    d: {\n      pressed: false\n    },\n    ArrowRight: {\n      pressed: false\n    },\n    ArrowLeft: {\n      pressed: false\n    }\n  });\n  const [lastKey, setLastKey] = useState('');\n  const [gravity] = useState(0.7);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = 1024;\n    canvas.height = 576;\n    setPlayer(new Sprite({\n      position: {\n        x: 0,\n        y: 0\n      },\n      velocity: {\n        x: 0,\n        y: 0\n      }\n    }));\n    setEnemy(new Sprite({\n      position: {\n        x: 400,\n        y: 100\n      },\n      velocity: {\n        x: 0,\n        y: 0\n      },\n      color: 'blue',\n      offset: {\n        x: -50,\n        y: 0\n      }\n    }));\n\n    // Event listeners\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    function handleKeyDown(event) {\n      switch (event.key) {\n        case 'd':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            d: {\n              pressed: true\n            }\n          }));\n          setLastKey('d');\n          break;\n        case 'a':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            a: {\n              pressed: true\n            }\n          }));\n          setLastKey('a');\n          break;\n        case ' ':\n          player.attack();\n          break;\n        case 'ArrowRight':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            ArrowRight: {\n              pressed: true\n            }\n          }));\n          setLastKey('ArrowRight');\n          break;\n        case 'ArrowLeft':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            ArrowLeft: {\n              pressed: true\n            }\n          }));\n          setLastKey('ArrowLeft');\n          break;\n        default:\n          break;\n      }\n    }\n    function handleKeyUp(event) {\n      switch (event.key) {\n        case 'd':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            d: {\n              pressed: false\n            }\n          }));\n          break;\n        case 'a':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            a: {\n              pressed: false\n            }\n          }));\n          break;\n        case 'ArrowRight':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            ArrowRight: {\n              pressed: false\n            }\n          }));\n          break;\n        case 'ArrowLeft':\n          setKeys(prevKeys => ({\n            ...prevKeys,\n            ArrowLeft: {\n              pressed: false\n            }\n          }));\n          break;\n        default:\n          break;\n      }\n    }\n  }, [player]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const backgroundImage = new Image();\n    backgroundImage.src = './Images/background.png';\n    backgroundImage.onload = () => {\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n      player.draw(ctx);\n      enemy.draw(ctx);\n    };\n    animate();\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [player, enemy]);\n  function Sprite({\n    position,\n    velocity,\n    color = 'red',\n    offset = {\n      x: 0,\n      y: 0\n    }\n  }) {\n    this.position = position;\n    this.velocity = velocity;\n    this.height = 150;\n    this.width = 50;\n    this.attackbox = {\n      position: {\n        x: this.position.x,\n        y: this.position.y\n      },\n      offset,\n      width: 100,\n      height: 50\n    };\n    this.isAttacking = false;\n    this.color = color;\n    this.draw = ctx => {\n      ctx.fillStyle = this.color;\n      ctx.fillRect(this.position.x, this.position.y, 50, this.height);\n      ctx.fillStyle = 'green';\n      ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y, this.attackbox.width, this.attackbox.height);\n    };\n    this.update = () => {\n      this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\n      this.attackbox.position.y = this.position.y;\n      this.position.x += this.velocity.x;\n      this.position.y += this.velocity.y;\n      if (this.position.y + this.height >= canvasRef.current.height) {\n        this.velocity.y = 0;\n        this.position.y = canvasRef.current.height - this.height;\n      } else {\n        this.velocity.y += gravity;\n      }\n    };\n    this.attack = () => {\n      this.isAttacking = true;\n      setTimeout(() => {\n        this.isAttacking = false;\n      }, 100);\n    };\n  }\n  function animate() {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the canvas\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw the background image\n    ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n    // Update and draw the sprites\n    player.update();\n    player.draw(ctx);\n    enemy.update();\n    enemy.draw(ctx);\n    player.velocity.x = 0;\n    enemy.velocity.x = 0;\n    if (keys.a.pressed && lastKey === 'a') {\n      player.velocity.x = -5;\n    } else if (keys.d.pressed && lastKey === 'd') {\n      player.velocity.x = 5;\n    }\n    if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\n      enemy.velocity.x = -5;\n    } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\n      enemy.velocity.x = 5;\n    }\n\n    // detect for collision\n    if (player.attackbox.position.x + player.attackbox.width >= enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width && player.attackbox.position.y + player.attackbox.height >= enemy.position.y && player.attackbox.position.y <= enemy.position.y + enemy.height && player.isAttacking) {\n      console.log('go');\n    }\n    window.requestAnimationFrame(animate);\n  }\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 201,\n    columnNumber: 10\n  }, this);\n};\n_s(Canvas, \"qKm+tx1QQzJqyGPLHZ37SWYJhXM=\");\n_c = Canvas;\nexport default Canvas;\n\n// import React, { useRef, useEffect } from 'react';\n// import spriteImage from './Images/background.png';\n\n// const Canvas = (props) => {\n//   const canvasRef = useRef(null);\n//   let player;\n//   let enemy;\n//   let backgroundImage;\n//   const keys = {\n//     a: {\n//       pressed: false,\n//     },\n//     d: {\n//       pressed: false,\n//     },\n//     ArrowRight: {\n//       pressed: false,\n//     },\n//     ArrowLeft: {\n//       pressed: false,\n//     },\n//   };\n//   let lastkey = ''; // Initialize lastkey with an empty string\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     player = new Sprite({\n//       position: { x: 150, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//     });\n\n//     enemy = new Sprite({\n//       position: { x: 450, y: 425 },\n//       velocity: { x: 0, y: 0 },\n//       color: 'blue'\n//     });\n\n//     backgroundImage.onload = () => {\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Draw the initial sprites\n//       player.draw(ctx);\n//       enemy.draw(ctx);\n//     };\n\n//     // Event listeners\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     function handleKeyDown(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = true;\n//           lastkey = 'd';\n//           break;\n//         case 'a':\n//           keys.a.pressed = true;\n//           lastkey = 'a';\n//           break;\n//           case ' ':\n//             player.attack()  \n//             break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = true;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = true;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//       }\n//     }\n\n//     function handleKeyUp(event) {\n//       switch (event.key) {\n//         case 'd':\n//           keys.d.pressed = false;\n//           break;\n//         case 'a':\n//           keys.a.pressed = false;\n//           break;\n//         case 'ArrowRight':\n//           keys.ArrowRight.pressed = true;\n//           enemy.lastkey = 'ArrowRight';\n//           break;\n//           case 'ArrowLeft':\n//           keys.ArrowLeft.pressed = true;\n//           enemy.lastkey = 'ArrowLeft';\n//           break;\n//       }\n//     }\n//   }, []);\n\n//   const gravity = 0.007;\n\n//   class Sprite {\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\n//       this.position = position;\n//       this.velocity = velocity;\n//       this.height = 150;\n//       this.width = 50;\n//       this.attackbox = {\n//         position: {\n//           x:this.position.x,\n//           y:this.position.y\n//         },\n//         offset,\n\n//         width: 100 ,\n//         height: 50\n//       }\n//       this.isAttacking = '';\n//       this.color = color;\n//     }\n\n//     draw(ctx) {\n//       ctx.fillStyle = this.color;\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\n//       // attackbox\n//       // if (this.isAttacking) {\n\n//       ctx.fillStyle = 'green';\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\n//     }\n//   // }\n\n//     update(ctx) {\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\n//       this.attackbox.position.y = this.position.y;\n\n//       this.position.x += this.velocity.x;\n//       this.position.y += this.velocity.y;\n//       if (this.position.y + this.height >= ctx.height) {\n//         this.velocity.y = 0;\n//         this.position.y = ctx.height - this.height;\n//       } else {\n//         this.velocity.y += gravity;\n//       }\n//     }\n//       attack() {\n//         this.isAttacking = true\n//         setTimeout(() => {\n//           this.isAttacking = false\n//         }, 100\n//         )\n\n//     }\n//   }\n\n//   function animate() {\n//     const canvas = canvasRef.current;\n\n//      if (canvas && player && enemy) {\n//       const ctx = canvas.getContext('2d');\n\n//       // Clear the canvas\n//       ctx.fillStyle = 'black';\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Update and draw the sprites\n//       player.update(canvas);\n//       player.draw(ctx);\n\n//       enemy.update(canvas);\n//       enemy.draw(ctx);\n\n//       player.velocity.x = 0;\n//       enemy.velocity.x = 0;\n\n//       if (keys.a.pressed && lastkey === 'a') {\n//         player.velocity.x = -5;\n//       } else if (keys.d.pressed && lastkey === 'd') {\n//         player.velocity.x = 5;\n//       }\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\n//         enemy.velocity.x = -5;\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\n//         enemy.velocity.x = 5;\n//       }\n//       // detect for collision\n//       if (player.attackbox.position.x + player.attackbox.width >= \n//         enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width &&\n//         player.attackbox.position.y + player.attackbox.height >= enemy.position.y\n//         && player.attackbox.position.y <= enemy.position.y + enemy.height &&\n//         player.isAttacking) {\n//         console.log('go');\n//       }\n\n//     }\n\n//     window.requestAnimationFrame(animate);\n//   }\n\n//   useEffect(() => {\n//     animate(); // Start the animation loop after the initial render\n//   }, []);\n\n//   return <canvas ref={canvasRef} {...props} />;\n// };\n\n// export default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","Canvas","_s","canvasRef","player","setPlayer","enemy","setEnemy","keys","setKeys","a","pressed","d","ArrowRight","ArrowLeft","lastKey","setLastKey","gravity","canvas","current","ctx","getContext","width","height","Sprite","position","x","y","velocity","color","offset","window","addEventListener","handleKeyDown","handleKeyUp","event","key","prevKeys","attack","backgroundImage","Image","src","onload","drawImage","draw","animate","removeEventListener","attackbox","isAttacking","fillStyle","fillRect","update","setTimeout","lastkey","console","log","requestAnimationFrame","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/Canvas.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\r\n\r\nconst Canvas = () => {\r\n  const canvasRef = useRef(null);\r\n  const [player, setPlayer] = useState(null);\r\n  const [enemy, setEnemy] = useState(null);\r\n  const [keys, setKeys] = useState({\r\n    a: { pressed: false },\r\n    d: { pressed: false },\r\n    ArrowRight: { pressed: false },\r\n    ArrowLeft: { pressed: false },\r\n  });\r\n  const [lastKey, setLastKey] = useState('');\r\n  const [gravity] = useState(0.7);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    canvas.width = 1024;\r\n    canvas.height = 576;\r\n\r\n    setPlayer(\r\n      new Sprite({\r\n        position: { x: 0, y: 0 },\r\n        velocity: { x: 0, y: 0 },\r\n      })\r\n    );\r\n\r\n    setEnemy(\r\n      new Sprite({\r\n        position: { x: 400, y: 100 },\r\n        velocity: { x: 0, y: 0 },\r\n        color: 'blue',\r\n        offset: { x: -50, y: 0 },\r\n      })\r\n    );\r\n\r\n    // Event listeners\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    function handleKeyDown(event) {\r\n      switch (event.key) {\r\n        case 'd':\r\n          setKeys((prevKeys) => ({ ...prevKeys, d: { pressed: true } }));\r\n          setLastKey('d');\r\n          break;\r\n        case 'a':\r\n          setKeys((prevKeys) => ({ ...prevKeys, a: { pressed: true } }));\r\n          setLastKey('a');\r\n          break;\r\n        case ' ':\r\n          player.attack();\r\n          break;\r\n        case 'ArrowRight':\r\n          setKeys((prevKeys) => ({ ...prevKeys, ArrowRight: { pressed: true } }));\r\n          setLastKey('ArrowRight');\r\n          break;\r\n        case 'ArrowLeft':\r\n          setKeys((prevKeys) => ({ ...prevKeys, ArrowLeft: { pressed: true } }));\r\n          setLastKey('ArrowLeft');\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    function handleKeyUp(event) {\r\n      switch (event.key) {\r\n        case 'd':\r\n          setKeys((prevKeys) => ({ ...prevKeys, d: { pressed: false } }));\r\n          break;\r\n        case 'a':\r\n          setKeys((prevKeys) => ({ ...prevKeys, a: { pressed: false } }));\r\n          break;\r\n        case 'ArrowRight':\r\n          setKeys((prevKeys) => ({ ...prevKeys, ArrowRight: { pressed: false } }));\r\n          break;\r\n        case 'ArrowLeft':\r\n          setKeys((prevKeys) => ({ ...prevKeys, ArrowLeft: { pressed: false } }));\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  }, [player]);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const backgroundImage = new Image();\r\n    backgroundImage.src = './Images/background.png';\r\n\r\n    backgroundImage.onload = () => {\r\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n      player.draw(ctx);\r\n      enemy.draw(ctx);\r\n    };\r\n\r\n    animate();\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [player, enemy]);\r\n\r\n  function Sprite({ position, velocity, color = 'red', offset = { x: 0, y: 0 } }) {\r\n    this.position = position;\r\n    this.velocity = velocity;\r\n    this.height = 150;\r\n    this.width = 50;\r\n    this.attackbox = {\r\n      position: {\r\n        x: this.position.x,\r\n        y: this.position.y,\r\n      },\r\n      offset,\r\n      width: 100,\r\n      height: 50,\r\n    };\r\n    this.isAttacking = false;\r\n    this.color = color;\r\n\r\n    this.draw = (ctx) => {\r\n      ctx.fillStyle = this.color;\r\n      ctx.fillRect(this.position.x, this.position.y, 50, this.height);\r\n      ctx.fillStyle = 'green';\r\n      ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y, this.attackbox.width, this.attackbox.height);\r\n    };\r\n\r\n    this.update = () => {\r\n      this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\r\n      this.attackbox.position.y = this.position.y;\r\n\r\n      this.position.x += this.velocity.x;\r\n      this.position.y += this.velocity.y;\r\n\r\n      if (this.position.y + this.height >= canvasRef.current.height) {\r\n        this.velocity.y = 0;\r\n        this.position.y = canvasRef.current.height - this.height;\r\n      } else {\r\n        this.velocity.y += gravity;\r\n      }\r\n    };\r\n\r\n    this.attack = () => {\r\n      this.isAttacking = true;\r\n      setTimeout(() => {\r\n        this.isAttacking = false;\r\n      }, 100);\r\n    };\r\n  }\r\n\r\n  function animate() {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // Clear the canvas\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Draw the background image\r\n    ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n    // Update and draw the sprites\r\n    player.update();\r\n    player.draw(ctx);\r\n\r\n    enemy.update();\r\n    enemy.draw(ctx);\r\n\r\n    player.velocity.x = 0;\r\n    enemy.velocity.x = 0;\r\n\r\n    if (keys.a.pressed && lastKey === 'a') {\r\n      player.velocity.x = -5;\r\n    } else if (keys.d.pressed && lastKey === 'd') {\r\n      player.velocity.x = 5;\r\n    }\r\n    if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\r\n      enemy.velocity.x = -5;\r\n    } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\r\n      enemy.velocity.x = 5;\r\n    }\r\n\r\n    // detect for collision\r\n    if (\r\n      player.attackbox.position.x + player.attackbox.width >= enemy.position.x &&\r\n      player.attackbox.position.x <= enemy.position.x + enemy.width &&\r\n      player.attackbox.position.y + player.attackbox.height >= enemy.position.y &&\r\n      player.attackbox.position.y <= enemy.position.y + enemy.height &&\r\n      player.isAttacking\r\n    ) {\r\n      console.log('go');\r\n    }\r\n\r\n    window.requestAnimationFrame(animate);\r\n  }\r\n\r\n  return <canvas ref={canvasRef} />;\r\n};\r\n\r\nexport default Canvas;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import React, { useRef, useEffect } from 'react';\r\n// import spriteImage from './Images/background.png';\r\n\r\n// const Canvas = (props) => {\r\n//   const canvasRef = useRef(null);\r\n//   let player;\r\n//   let enemy;\r\n//   let backgroundImage;\r\n//   const keys = {\r\n//     a: {\r\n//       pressed: false,\r\n//     },\r\n//     d: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowRight: {\r\n//       pressed: false,\r\n//     },\r\n//     ArrowLeft: {\r\n//       pressed: false,\r\n//     },\r\n//   };\r\n//   let lastkey = ''; // Initialize lastkey with an empty string\r\n\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n\r\n//     player = new Sprite({\r\n//       position: { x: 150, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//     });\r\n\r\n//     enemy = new Sprite({\r\n//       position: { x: 450, y: 425 },\r\n//       velocity: { x: 0, y: 0 },\r\n//       color: 'blue'\r\n//     });\r\n\r\n//     backgroundImage.onload = () => {\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the initial sprites\r\n//       player.draw(ctx);\r\n//       enemy.draw(ctx);\r\n//     };\r\n\r\n//     // Event listeners\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n\r\n//     function handleKeyDown(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = true;\r\n//           lastkey = 'd';\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = true;\r\n//           lastkey = 'a';\r\n//           break;\r\n//           case ' ':\r\n//             player.attack()  \r\n//             break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = true;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = true;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//       }\r\n//     }\r\n\r\n//     function handleKeyUp(event) {\r\n//       switch (event.key) {\r\n//         case 'd':\r\n//           keys.d.pressed = false;\r\n//           break;\r\n//         case 'a':\r\n//           keys.a.pressed = false;\r\n//           break;\r\n//         case 'ArrowRight':\r\n//           keys.ArrowRight.pressed = true;\r\n//           enemy.lastkey = 'ArrowRight';\r\n//           break;\r\n//           case 'ArrowLeft':\r\n//           keys.ArrowLeft.pressed = true;\r\n//           enemy.lastkey = 'ArrowLeft';\r\n//           break;\r\n//       }\r\n//     }\r\n//   }, []);\r\n\r\n//   const gravity = 0.007;\r\n\r\n//   class Sprite {\r\n//     constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\r\n//       this.position = position;\r\n//       this.velocity = velocity;\r\n//       this.height = 150;\r\n//       this.width = 50;\r\n//       this.attackbox = {\r\n//         position: {\r\n//           x:this.position.x,\r\n//           y:this.position.y\r\n//         },\r\n//         offset,\r\n        \r\n//         width: 100 ,\r\n//         height: 50\r\n//       }\r\n//       this.isAttacking = '';\r\n//       this.color = color;\r\n//     }\r\n\r\n//     draw(ctx) {\r\n//       ctx.fillStyle = this.color;\r\n//       ctx.fillRect(this.position.x, this.position.y, 50, this.height);\r\n//       // attackbox\r\n//       // if (this.isAttacking) {\r\n\r\n      \r\n//       ctx.fillStyle = 'green';\r\n//       ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\r\n//     }\r\n//   // }\r\n\r\n//     update(ctx) {\r\n//       this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\r\n//       this.attackbox.position.y = this.position.y;\r\n\r\n//       this.position.x += this.velocity.x;\r\n//       this.position.y += this.velocity.y;\r\n//       if (this.position.y + this.height >= ctx.height) {\r\n//         this.velocity.y = 0;\r\n//         this.position.y = ctx.height - this.height;\r\n//       } else {\r\n//         this.velocity.y += gravity;\r\n//       }\r\n//     }\r\n//       attack() {\r\n//         this.isAttacking = true\r\n//         setTimeout(() => {\r\n//           this.isAttacking = false\r\n//         }, 100\r\n//         )\r\n        \r\n      \r\n//     }\r\n//   }\r\n\r\n//   function animate() {\r\n//     const canvas = canvasRef.current;\r\n\r\n//      if (canvas && player && enemy) {\r\n//       const ctx = canvas.getContext('2d');\r\n\r\n//       // Clear the canvas\r\n//       ctx.fillStyle = 'black';\r\n//       ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Update and draw the sprites\r\n//       player.update(canvas);\r\n//       player.draw(ctx);\r\n\r\n//       enemy.update(canvas);\r\n//       enemy.draw(ctx);\r\n\r\n//       player.velocity.x = 0;\r\n//       enemy.velocity.x = 0;\r\n\r\n\r\n//       if (keys.a.pressed && lastkey === 'a') {\r\n//         player.velocity.x = -5;\r\n//       } else if (keys.d.pressed && lastkey === 'd') {\r\n//         player.velocity.x = 5;\r\n//       }\r\n//       if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\r\n//         enemy.velocity.x = -5;\r\n//       } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\r\n//         enemy.velocity.x = 5;\r\n//       }\r\n//       // detect for collision\r\n//       if (player.attackbox.position.x + player.attackbox.width >= \r\n//         enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width &&\r\n//         player.attackbox.position.y + player.attackbox.height >= enemy.position.y\r\n//         && player.attackbox.position.y <= enemy.position.y + enemy.height &&\r\n//         player.isAttacking) {\r\n//         console.log('go');\r\n//       }\r\n      \r\n//     }\r\n\r\n//     window.requestAnimationFrame(animate);\r\n//   }\r\n\r\n//   useEffect(() => {\r\n//     animate(); // Start the animation loop after the initial render\r\n//   }, []);\r\n\r\n//   return <canvas ref={canvasRef} {...props} />;\r\n// };\r\n\r\n// export default Canvas;"],"mappings":"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A;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA,IAAA6D,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}