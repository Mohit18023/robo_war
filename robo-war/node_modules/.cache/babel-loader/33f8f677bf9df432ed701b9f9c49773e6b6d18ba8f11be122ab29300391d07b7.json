{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Meenal Jain\\\\Desktop\\\\robo_war\\\\robo-war\\\\src\\\\CanvasDrawing.js\",\n  _s = $RefreshSig$();\n// // // // // // CanvasDrawing.js\n\n// // // // // import React, { useRef, useEffect } from 'react';\n// // // // // import './Components.css'; // Import your component-specific CSS file\n\n// // // // // import spriteImage from './img/background.png';\n\n// // // // // function CanvasDrawing() {\n// // // // //   // Create a ref for the canvas element\n// // // // //   const canvasRef = useRef(null);\n\n// // // // //   useEffect(() => {\n// // // // //     // const canvas = canvasRef.current;\n// // // // //     // const ctx = canvas.getContext('2d');\n\n// // // // //     const canvas = document.querySelector('canvas');\n// // // // //     const ctx = canvas.getContext('2d')\n// // // // //     // Set canvas dimensions\n// // // // //     canvas.width = 1024;\n// // // // //     canvas.height = 576;\n\n// // // // //     // Drawing code here\n// // // // //     // ctx.fillStyle = 'blue';\n// // // // //     ctx.fillRect(0, 0, canvas.width, canvas.height);\n// // // // //     const gravity = 0.7\n\n// // // // //     const Components = () => {\n// // // // //       return (\n// // // // //         <div className=\"SpriteImage\">\n// // // // //           {/* Your component content */}\n// // // // //         </div>\n// // // // //       );\n// // // // //     };\n// // // // //     // Cleanup (optional)\n// // // // //     return () => {\n// // // // //       // You can perform cleanup here if needed\n// // // // //     };\n// // // // //   }, []); // Empty dependency array to run only once\n\n// // // // //   return (\n// // // // //     <div>\n// // // // //       <canvas ref={canvasRef}></canvas>\n// // // // //     </div>\n// // // // //   );\n// // // // // }\n\n// // // // // export default CanvasDrawing;\n\n// // // // import React, { useRef, useEffect, useState } from 'react';\n// // // // import './Components.css'; // Import your component-specific CSS file\n\n// // // // import spriteImage from './img/background.png';\n\n// // // // const initialPlayerState = {\n// // // //   position: {\n// // // //     x: 0,\n// // // //     y: 0\n// // // //   },\n// // // //   velocity: {\n// // // //     x: 0,\n// // // //     y: 0\n// // // //   },\n// // // //   offset: {\n// // // //     x: 0,\n// // // //     y: 0\n// // // //   },\n// // // //   imageSrc: './img/samuraiMack/Idle.png',\n// // // //   framesMax: 8,\n// // // //   scale: 2.5,\n// // // //   offset: {\n// // // //     x: 215,\n// // // //     y: 157\n// // // //   },\n// // // //   sprites: {\n// // // //     idle: {\n// // // //       imageSrc: './img/samuraiMack/Idle.png',\n// // // //       framesMax: 8\n// // // //     },\n// // // //     // ... Add other sprite definitions here\n// // // //   },\n// // // //   attackBox: {\n// // // //     offset: {\n// // // //       x: 100,\n// // // //       y: 50\n// // // //     },\n// // // //     width: 160,\n// // // //     height: 50\n// // // //   }\n// // // // };\n// // // // const initialEnemyState = {\n// // // //   position: {\n// // // //     x: 400,\n// // // //     y: 100\n// // // //   },\n// // // //   velocity: {\n// // // //     x: 0,\n// // // //     y: 0\n// // // //   },\n// // // //   color: 'blue',\n// // // //   offset: {\n// // // //     x: -50,\n// // // //     y: 0\n// // // //   },\n// // // //   imageSrc: './img/kenji/Idle.png',\n// // // //   framesMax: 4,\n// // // //   scale: 2.5,\n// // // //   offset: {\n// // // //     x: 215,\n// // // //     y: 167\n// // // //   },\n// // // //   sprites: {\n// // // //     idle: {\n// // // //       imageSrc: './img/kenji/Idle.png',\n// // // //       framesMax: 4\n// // // //     },\n// // // //     // ... Add other sprite definitions here\n// // // //   },\n// // // //   attackBox: {\n// // // //     offset: {\n// // // //       x: -170,\n// // // //       y: 50\n// // // //     },\n// // // //     width: 170,\n// // // //     height: 50\n// // // //   }\n// // // // };\n// // // // function CanvasDrawing() {\n// // // //   // Create a ref for the canvas element\n// // // //   const canvasRef = useRef(null);\n// // // //   const [player, setPlayer] = useState(initialPlayerState);\n// // // //   const [enemy, setEnemy] = useState(initialEnemyState);\n// // // //   const [keys, setKeys] = useState({\n// // // //     a: {\n// // // //       pressed: false\n// // // //     },\n// // // //     d: {\n// // // //       pressed: false\n// // // //     },\n// // // //     ArrowRight: {\n// // // //       pressed: false\n// // // //     },\n// // // //     ArrowLeft: {\n// // // //       pressed: false\n// // // //     }\n// // // //   });\n// // // //   useEffect(() => {\n// // // //     const canvas = canvasRef.current;\n// // // //     const ctx = canvas.getContext('2d');\n// // // //     const gravity = 0.7;\n\n// // // //     // Set canvas dimensions\n// // // //     canvas.width = 1024;\n// // // //     canvas.height = 576;\n\n// // // //     // Use the spriteImage as the background\n// // // //     const backgroundImage = new Image();\n// // // //     backgroundImage.src = spriteImage;\n\n// // // //     // Once the image is loaded, draw it on the canvas\n// // // //     backgroundImage.onload = () => {\n// // // //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n// // // //     // Other drawing code here\n// // // //     // ctx.fillStyle = 'blue';\n// // // //     // ctx.fillRect(0, 0, canvas.width, canvas.height);\n// // // // // Draw the sprite image\n// // // // const playerImage = new Image();\n// // // // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\n// // // // playerImage.onload = () => {\n// // // //   // Draw the player image at the desired position (player.position.x, player.position.y)\n// // // //   ctx.drawImage(playerImage, player.position.x, player.position.y);\n// // // // };\n// // // // };\n// // // //     const handleKeyDown = (event) => {\n// // // //       // Update the keys state based on the pressed key\n// // // //       setKeys((prevKeys) => ({\n// // // //         ...prevKeys,\n// // // //         [event.key]: {\n// // // //           pressed: true\n// // // //         }\n// // // //       }));\n// // // //     };\n\n// // // //     const handleKeyUp = (event) => {\n// // // //       // Update the keys state when a key is released\n// // // //       setKeys((prevKeys) => ({\n// // // //         ...prevKeys,\n// // // //         [event.key]: {\n// // // //           pressed: false\n// // // //         }\n// // // //       }));\n// // // //     };\n\n// // // //     window.addEventListener('keydown', handleKeyDown);\n// // // //     window.addEventListener('keyup', handleKeyUp);\n\n// // // //     // Cleanup (optional)\n// // // //     return () => {\n// // // //       // You can perform cleanup here if needed\n// // // //     };\n// // // //   }, []); // Empty dependency array to run only once\n\n// // // //   return (\n// // // //     <div>\n// // // //       <canvas ref={canvasRef}></canvas>\n// // // //     </div>\n// // // //   );\n// // // // }\n\n// // // // export default CanvasDrawing;\n\n// // // import React, { useRef, useEffect, useState } from 'react';\n// // // import './Components.css'; // Import your component-specific CSS file\n\n// // // import spriteImage from './Images/background.png';\n// // // import kenjiIdle from './Images/kenji/Idle.png';\n// // // import samuraiIdle from './Images/samuraiMack/Idle.png';\n\n// // // const initialPlayerState = {\n// // //   position: {\n// // //     x: 0,\n// // //     y: 0\n// // //   },\n// // //   velocity: {\n// // //     x: 0,\n// // //     y: 0\n// // //   },\n// // //   offset: {\n// // //     x: 0,\n// // //     y: 0\n// // //   },\n// // //   // imageSrc: './img/samuraiMack/Idle.png',\n// // //   imageSrc: samuraiIdle,\n// // //   framesMax: 8,\n// // //   scale: 2.5,\n// // //   offset: {\n// // //     x: 215,\n// // //     y: 157\n// // //   },\n// // //   sprites: {\n// // //     idle: {\n// // //       // imageSrc: './img/samuraiMack/Idle.png',\n// // //       imageSrc: samuraiIdle,\n// // //       framesMax: 8\n// // //     },\n// // //     // ... Add other sprite definitions here\n// // //   },\n// // //   attackBox: {\n// // //     offset: {\n// // //       x: 100,\n// // //       y: 50\n// // //     },\n// // //     width: 160,\n// // //     height: 50\n// // //   }\n// // // };\n// // // const initialEnemyState = {\n// // //   position: {\n// // //     x: 400,\n// // //     y: 100\n// // //   },\n// // //   velocity: {\n// // //     x: 0,\n// // //     y: 0\n// // //   },\n// // //   color: 'blue',\n// // //   offset: {\n// // //     x: -50,\n// // //     y: 0\n// // //   },\n// // //   // imageSrc: './img/kenji/Idle.png',\n// // //   imageSrc: kenjiIdle,\n// // //   framesMax: 4,\n// // //   scale: 2.5,\n// // //   offset: {\n// // //     x: 215,\n// // //     y: 167\n// // //   },\n// // //   sprites: {\n// // //     idle: {\n// // //       // imageSrc: './img/kenji/Idle.png',\n// // //       imageSrc: kenjiIdle,\n// // //       framesMax: 4\n// // //     },\n// // //     // ... Add other sprite definitions here\n// // //   },\n// // //   attackBox: {\n// // //     offset: {\n// // //       x: -170,\n// // //       y: 50\n// // //     },\n// // //     width: 170,\n// // //     height: 50\n// // //   }\n// // // };\n// // // function CanvasDrawing() {\n// // //   // Create a ref for the canvas element\n// // //   const canvasRef = useRef(null);\n// // //   const [player, setPlayer] = useState(initialPlayerState);\n// // //   const [enemy, setEnemy] = useState(initialEnemyState);\n// // //   const [keys, setKeys] = useState({\n// // //     a: {\n// // //       pressed: false\n// // //     },\n// // //     d: {\n// // //       pressed: false\n// // //     },\n// // //     ArrowRight: {\n// // //       pressed: false\n// // //     },\n// // //     ArrowLeft: {\n// // //       pressed: false\n// // //     }\n// // //   });\n// // //   useEffect(() => {\n// // //     const canvas = canvasRef.current;\n// // //     const ctx = canvas.getContext('2d');\n// // //     const gravity = 0.7;\n\n// // //     // Set canvas dimensions\n// // //     canvas.width = 1024;\n// // //     canvas.height = 576;\n\n// // //     // Use the spriteImage as the background\n// // //     const backgroundImage = new Image();\n// // //     backgroundImage.src = spriteImage;\n\n// // //     // Once the image is loaded, draw it on the canvas\n// // //     backgroundImage.onload = () => {\n// // //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n// // //     // Other drawing code here\n// // //     // ctx.fillStyle = 'blue';\n// // //     // ctx.fillRect(0, 0, canvas.width, canvas.height);\n// // // // Draw the sprite image\n// // // const playerImage = new Image();\n// // // // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\n// // // playerImage.src = kenjiIdle; \n// // // playerImage.onload = () => {\n// // //   // Draw the player image at the desired position (player.position.x, player.position.y)\n// // //   ctx.drawImage(playerImage, player.position.x, player.position.y);\n// // // };\n// // // };\n// // //     const handleKeyDown = (event) => {\n// // //       // Update the keys state based on the pressed key\n// // //       setKeys((prevKeys) => ({\n// // //         ...prevKeys,\n// // //         [event.key]: {\n// // //           pressed: true\n// // //         }\n// // //       }));\n// // //     };\n\n// // //     const handleKeyUp = (event) => {\n// // //       // Update the keys state when a key is released\n// // //       setKeys((prevKeys) => ({\n// // //         ...prevKeys,\n// // //         [event.key]: {\n// // //           pressed: false\n// // //         }\n// // //       }));\n// // //     };\n\n// // //     window.addEventListener('keydown', handleKeyDown);\n// // //     window.addEventListener('keyup', handleKeyUp);\n\n// // //     // Cleanup (optional)\n// // //     return () => {\n// // //       // You can perform cleanup here if needed\n// // //     };\n// // //   }, []); // Empty dependency array to run only once\n\n// // //   return (\n// // //     <div>\n// // //       <canvas ref={canvasRef}></canvas>\n// // //     </div>\n// // //   );\n// // // }\n\n// // // export default CanvasDrawing;\n\n// // import React, { useRef, useEffect, useState } from 'react';\n// // import './Components.css';\n\n// // import spriteImage from './Images/background.png'; // Load the single sprite sheet\n// // import { AnimationFrame } from './animationFrame.js'; // You might need a utility for handling animations\n// // import kenjiImage from './Idle.png'; // Load the single sprite sheet\n\n// // const initialPlayerState = {\n// //   position: {\n// //     x: 0,\n// //     y: 0\n// //   },\n// //   velocity: {\n// //     x: 10,\n// //     y: 0\n// //   },\n// //   scale: 2.5,\n// // };\n\n// // // Define frame dimensions and animation parameters\n// // const kenjiFrameWidth = 64; // Width of a single frame in pixels\n// // const kenjiFrameHeight = 64; // Height of a single frame in pixels\n// // const kenjiTotalFrames = 8; // Total number of frames in Kenji's animation\n// // const kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\n\n// // const samuraiFrameWidth = 64; // Width of a single frame in pixels\n// // const samuraiFrameHeight = 64; // Height of a single frame in pixels\n// // const samuraiTotalFrames = 8; // Total number of frames in Samurai's animation\n// // const samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\n\n// // function CanvasDrawing() {\n// //   const canvasRef = useRef(null);\n// //   const [player, setPlayer] = useState(initialPlayerState);\n// //   const [currentFrame, setCurrentFrame] = useState(0);\n\n// //   useEffect(() => {\n// //     const canvas = canvasRef.current;\n// //     const ctx = canvas.getContext('2d');\n// //     const gravity = 0.7;\n\n// //     // Set canvas dimensions\n// //     canvas.width = 1024;\n// //     canvas.height = 576;\n\n// //     // Use the spriteImage as the background\n// //     const backgroundImage = new Image();\n// //     backgroundImage.src = spriteImage;\n// //     // const canvas = document.getElementById('myCanvas');\n// //     // const ctx = canvas.getContext('2d');\n// //     // const kenjiImage = new Image();\n// //     // kenjiImage.src = './Idle.png';\n\n// //     // Create an animation frame object for each character\n// //     const kenjiAnimationFrame = new AnimationFrame({\n// //       image: kenjiImage,\n// //       frameWidth: kenjiFrameWidth,\n// //       frameHeight: kenjiFrameHeight,\n// //       totalFrames: kenjiTotalFrames,\n// //       animationSpeed: kenjiAnimationSpeed,\n\n// //     });\n// //     kenjiImage.onload = function() {\n// //       ctx.drawImage(kenjiImage, 0,0); // Replace x and y with the coordinates where you want to draw the image.\n// //     };\n\n// //     const samuraiAnimationFrame = new AnimationFrame({\n// //       image: backgroundImage,\n// //       frameWidth: samuraiFrameWidth,\n// //       frameHeight: samuraiFrameHeight,\n// //       totalFrames: samuraiTotalFrames,\n// //       animationSpeed: samuraiAnimationSpeed,\n// //     });\n\n// //     // Define key state for controlling characters\n// //     const keys = {\n// //       ArrowLeft: false,\n// //       ArrowRight: false,\n// //       Space: false,\n// //     };\n\n// //     // Handle keydown event\n// //     const handleKeyDown = (event) => {\n// //       if (event.key === 'ArrowLeft') {\n// //         keys.ArrowLeft = true;\n// //       } else if (event.key === 'ArrowRight') {\n// //         keys.ArrowRight = true;\n// //       } else if (event.key === 'Space') {\n// //         keys.Space = true;\n// //       }\n// //     };\n\n// //     // Handle keyup event\n// //     const handleKeyUp = (event) => {\n// //       if (event.key === 'ArrowLeft') {\n// //         keys.ArrowLeft = false;\n// //       } else if (event.key === 'ArrowRight') {\n// //         keys.ArrowRight = false;\n// //       } else if (event.key === 'Space') {\n// //         keys.Space = false;\n// //       }\n// //     };\n\n// //     // Add event listeners for keydown and keyup\n// //     window.addEventListener('keydown', handleKeyDown);\n// //     window.addEventListener('keyup', handleKeyUp);\n\n// //     // Start the animation loop\n// //     const animate = () => {\n// //       ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n// //       // Draw the background image\n// //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n// //       // Update the player's position based on keyboard input\n// //       if (keys.ArrowLeft) {\n// //         player.position.x -= player.velocity.x;\n// //       } else if (keys.ArrowRight) {\n// //         player.position.x += player.velocity.x;\n// //       }\n\n// //       // Draw Kenji character\n// //       kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\n\n// //       // Draw Samurai character\n// //       samuraiAnimationFrame.draw(ctx, player.position.x + 200, player.position.y);\n\n// //       // Update the current frame for each character's animation\n// //       setCurrentFrame((prevFrame) => prevFrame + 1);\n\n// //       requestAnimationFrame(animate);\n// //     };\n\n// //     animate();\n\n// //     // Cleanup (optional)\n// //     return () => {\n// //       // Remove event listeners or do other cleanup if needed\n// //       window.removeEventListener('keydown', handleKeyDown);\n// //       window.removeEventListener('keyup', handleKeyUp);\n// //     };\n// //   }, []); // Empty dependency array to run only once\n\n// //   return (\n// //     <div>\n// //       <canvas ref={canvasRef}></canvas>\n// //     </div>\n// //   );\n// // }\n\n// // export default CanvasDrawing;\n\n// import React, { useRef, useEffect, useState } from 'react';\n// import './Components.css';\n\n// import spriteImage from './Images/background.png'; // Load the single sprite sheet\n// import { AnimationFrame } from './animationFrame.js'; // You might need a utility for handling animations\n// import kenjiImage from './Idle1.png'; // Load the single sprite sheet\n\n// // ...\n\n// function CanvasDrawing() {\n//   // ...\n\n//   useEffect(() => {\n//     // ...\n\n//     // Use the kenjiImage as the character sprite\n//     const image = new Image();\n//     image.src = kenjiImage;\n\n//     // image.onload = function() {\n//       // Now, 'image' is an Image object, and you can use it safely.\n//       // ...\n//       ctx.drawImage(image, 0,0);\n//     };\n\n//     // ...\n//   }, []); // Empty dependency array to run only once\n\n//   // ...\n// }\n\n// export default CanvasDrawing;\n\n//   2\n// import React, { useRef, useEffect, useState } from 'react';\n// import './Components.css';\n\n// import spriteImage from './Images/background.png'; // Load the single sprite sheet\n// import { AnimationFrame } from './AnimationFrame.js'; // You might need a utility for handling animations\n// import kenjiImage from './Idle3 .png'; // Load the single sprite sheet\n// import samuraiImage from './fighter1.png'; // Load the single sprite sheet\n\n// const gravity = 0.7;\n// const initialPlayerState = {\n//   position: {\n//     x: 200,\n//     y: 400\n//   },\n//   velocity: {\n//     x: 10,\n//     y: 0\n//   },\n//   scale: 2.5,\n// };\n// // Define frame dimensions and animation parameters\n// const kenjiFrameWidth = 284; // Width of a single frame in pixels\n// const kenjiFrameHeight = 600; // Height of a single frame in pixels\n// const kenjiTotalFrames = 1; // Total number of frames in Kenji's animation\n// const kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\n\n// const samuraiFrameWidth = 284; // Width of a single frame in pixels\n// const samuraiFrameHeight = 600; // Height of a single frame in pixels\n// const samuraiTotalFrames = 1; // Total number of frames in Samurai's animation\n// const samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\n\n// function CanvasDrawing() {\n//   const canvasRef = useRef(null);\n//   const [player, setPlayer] = useState(initialPlayerState);\n//   const [currentFrame, setCurrentFrame] = useState(0);\n\n//   useEffect(() => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext('2d');\n//     // const gravity = 0.7;\n\n//     // Set canvas dimensions\n//     canvas.width = 1024;\n//     canvas.height = 576;\n\n//     // Use the spriteImage as the background\n//     const backgroundImage = new Image();\n//     backgroundImage.src = spriteImage;\n\n//     // Use kenjiImage as the character sprite\n//     const image = new Image();\n//     image.src = kenjiImage;\n\n//     image.onload = function() {\n//       // The 'image' is now fully loaded and can be safely used in your drawing logic.\n//       // For example, you can draw it here.\n//       ctx.drawImage(image, 50, 50); // Replace x and y with the coordinates where you want to draw the image.\n//     };\n// // Use samuraiImage as the character sprite\n//     const fighter = new Image();\n//     fighter.src = samuraiImage;\n\n//     fighter.onload = function() {\n//       // The 'image' is now fully loaded and can be safely used in your drawing logic.\n//       // For example, you can draw it here.\n//       ctx.drawImage(fighter, 50, 50); // Replace x and y with the coordinates where you want to draw the image.\n//     };\n\n//     // Create an animation frame object for each character\n//     const kenjiAnimationFrame = new AnimationFrame({\n//       image: image,\n//       frameWidth: kenjiFrameWidth,\n//       frameHeight: kenjiFrameHeight,\n//       totalFrames: kenjiTotalFrames,\n//       animationSpeed: kenjiAnimationSpeed,\n//     });\n\n//     const samuraiAnimationFrame = new AnimationFrame({\n//       image: fighter,\n//       frameWidth: samuraiFrameWidth,\n//       frameHeight: samuraiFrameHeight,\n//       totalFrames: samuraiTotalFrames,\n//       animationSpeed: samuraiAnimationSpeed,\n//     });\n\n//     // Define key state for controlling characters\n//     const keys = {\n//       ArrowLeft: false,\n//       ArrowRight: false,\n//       Space: false,\n//     };\n\n//     // Handle keydown event\n//     const handleKeyDown = (event) => {\n//       if (event.key === 'ArrowLeft') {\n//         keys.ArrowLeft = true;\n//       } else if (event.key === 'ArrowRight') {\n//         keys.ArrowRight = true;\n//       } else if (event.key === 'Space') {\n//         keys.Space = true;\n//       }\n//     };\n\n//     // Handle keyup event\n//     const handleKeyUp = (event) => {\n//       if (event.key === 'ArrowLeft') {\n//         keys.ArrowLeft = false;\n//       } else if (event.key === 'ArrowRight') {\n//         keys.ArrowRight = false;\n//       } else if (event.key === 'Space') {\n//         keys.Space = false;\n//       }\n//     };\n\n//     // Add event listeners for keydown and keyup\n//     window.addEventListener('keydown', handleKeyDown);\n//     window.addEventListener('keyup', handleKeyUp);\n\n//     // Start the animation loop\n//     const animate = () => {\n//       ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n//       // Draw the background image\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n//       // Update the player's position based on keyboard input\n//       if (keys.ArrowLeft) {\n//         player.position.x -= player.velocity.x;\n//       } else if (keys.ArrowRight) {\n//         player.position.x += player.velocity.x;\n//       }\n\n//       // Draw Kenji character\n//       kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\n\n//       // Draw Samurai character\n//       samuraiAnimationFrame.draw(ctx, player.position.x + 400, player.position.y);\n\n//       // Update the current frame for each character's animation\n//       setCurrentFrame((prevFrame) => prevFrame + 1);\n\n//       requestAnimationFrame(animate);\n//     };\n\n//     animate();\n\n//     // Cleanup (optional)\n//     return () => {\n//       // Remove event listeners or do other cleanup if needed\n//       window.removeEventListener('keydown', handleKeyDown);\n//       window.removeEventListener('keyup', handleKeyUp);\n//     };\n//   }, []); // Empty dependency array to run only once\n\n//   return (\n//     <div>\n//       <canvas ref={canvasRef}></canvas>\n//     </div>\n//   );\n// }\n\n// export default CanvasDrawing;\n\nimport React, { useRef, useEffect, useState } from 'react';\nimport './Components.css';\nimport spriteImage from './Images/background.png';\nimport { AnimationFrame } from './AnimationFrame.js';\nimport kenjiImage from './Idle3 .png';\nimport samuraiImage from './fighter1.png';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst gravity = 0.7;\nconst initialPlayer1State = {\n  position: {\n    x: 100,\n    y: 400\n  },\n  velocity: {\n    x: 10,\n    y: 0\n  },\n  scale: 2.5\n};\nconst initialPlayer2State = {\n  position: {\n    x: 250,\n    y: 400\n  },\n  velocity: {\n    x: 10,\n    y: 0\n  },\n  scale: 2.5\n};\nconst kenjiFrameWidth = 284;\nconst kenjiFrameHeight = 600;\nconst kenjiTotalFrames = 1;\nconst kenjiAnimationSpeed = 10;\nconst samuraiFrameWidth = 284;\nconst samuraiFrameHeight = 600;\nconst samuraiTotalFrames = 1;\nconst samuraiAnimationSpeed = 10;\nfunction CanvasDrawing() {\n  _s();\n  const canvasRef = useRef(null);\n  const [player1, setPlayer1] = useState(initialPlayer1State);\n  const [player2, setPlayer2] = useState(initialPlayer2State);\n  const [currentFrame, setCurrentFrame] = useState(0);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = 1024;\n    canvas.height = 576;\n    const backgroundImage = new Image();\n    backgroundImage.src = spriteImage;\n    const image = new Image();\n    image.src = kenjiImage;\n    image.onload = function () {\n      ctx.drawImage(image, 50, 50);\n    };\n    const fighter = new Image();\n    fighter.src = samuraiImage;\n    fighter.onload = function () {\n      ctx.drawImage(fighter, 50, 50);\n    };\n    const kenjiAnimationFrame = new AnimationFrame({\n      image: image,\n      frameWidth: kenjiFrameWidth,\n      frameHeight: kenjiFrameHeight,\n      totalFrames: kenjiTotalFrames,\n      animationSpeed: kenjiAnimationSpeed\n    });\n    const samuraiAnimationFrame = new AnimationFrame({\n      image: fighter,\n      frameWidth: samuraiFrameWidth,\n      frameHeight: samuraiFrameHeight,\n      totalFrames: samuraiTotalFrames,\n      animationSpeed: samuraiAnimationSpeed\n    });\n    const keys = {\n      a: false,\n      d: false,\n      w: false,\n      space: false,\n      ArrowLeft: false,\n      ArrowRight: false,\n      ArrowUp: false,\n      ArrowDown: false\n    };\n    const handleKeyDown = event => {\n      if (event.key === 'a') {\n        keys.a = true;\n      } else if (event.key === 'd') {\n        keys.d = true;\n      } else if (event.key === 'w') {\n        keys.w = true;\n      } else if (event.key === ' ') {\n        keys.space = true;\n      } else if (event.key === 'ArrowLeft') {\n        keys.ArrowLeft = true;\n      } else if (event.key === 'ArrowRight') {\n        keys.ArrowRight = true;\n      } else if (event.key === 'ArrowUp') {\n        keys.ArrowUp = true;\n      } else if (event.key === 'ArrowDown') {\n        keys.ArrowDown = true;\n      }\n    };\n    const handleKeyUp = event => {\n      if (event.key === 'a') {\n        keys.a = false;\n      } else if (event.key === 'd') {\n        keys.d = false;\n      } else if (event.key === 'w') {\n        keys.w = false;\n      } else if (event.key === ' ') {\n        keys.space = false;\n      } else if (event.key === 'ArrowLeft') {\n        keys.ArrowLeft = false;\n      } else if (event.key === 'ArrowRight') {\n        keys.ArrowRight = false;\n      } else if (event.key === 'ArrowUp') {\n        keys.ArrowUp = false;\n      } else if (event.key === 'ArrowDown') {\n        keys.ArrowDown = false;\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n      if (keys.a) {\n        player1.position.x -= player1.velocity.x;\n      } else if (keys.d) {\n        player1.position.x += player1.velocity.x;\n      } else if (keys.w) {\n        // Handle jump for player 1\n        // Add your jump logic here\n      } else if (keys.space) {\n        // Handle attack for player 1\n        // Add your attack logic here\n      }\n      if (keys.ArrowLeft) {\n        player2.position.x -= player2.velocity.x;\n      } else if (keys.ArrowRight) {\n        player2.position.x += player2.velocity.x;\n      } else if (keys.ArrowUp) {\n        // Handle jump for player 2\n        // Add your jump logic here\n      } else if (keys.ArrowDown) {\n        // Handle attack for player 2\n        // Add your attack logic here\n      }\n      kenjiAnimationFrame.draw(ctx, player1.position.x, player1.position.y);\n      samuraiAnimationFrame.draw(ctx, player2.position.x + 400, player2.position.y);\n      setCurrentFrame(prevFrame => prevFrame + 1);\n      requestAnimationFrame(animate);\n    };\n    animate();\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 943,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 942,\n    columnNumber: 5\n  }, this);\n}\n_s(CanvasDrawing, \"1E/2f9Arau1Sdufl5WlUqe8UO9Y=\");\n_c = CanvasDrawing;\nexport default CanvasDrawing;\nvar _c;\n$RefreshReg$(_c, \"CanvasDrawing\");","map":{"version":3,"names":["React","useRef","useEffect","useState","spriteImage","AnimationFrame","kenjiImage","samuraiImage","jsxDEV","_jsxDEV","gravity","initialPlayer1State","position","x","y","velocity","scale","initialPlayer2State","kenjiFrameWidth","kenjiFrameHeight","kenjiTotalFrames","kenjiAnimationSpeed","samuraiFrameWidth","samuraiFrameHeight","samuraiTotalFrames","samuraiAnimationSpeed","CanvasDrawing","_s","canvasRef","player1","setPlayer1","player2","setPlayer2","currentFrame","setCurrentFrame","canvas","current","ctx","getContext","width","height","backgroundImage","Image","src","image","onload","drawImage","fighter","kenjiAnimationFrame","frameWidth","frameHeight","totalFrames","animationSpeed","samuraiAnimationFrame","keys","a","d","w","space","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","handleKeyDown","event","key","handleKeyUp","window","addEventListener","animate","clearRect","draw","prevFrame","requestAnimationFrame","removeEventListener","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/CanvasDrawing.js"],"sourcesContent":["// // // // // // CanvasDrawing.js\r\n\r\n// // // // // import React, { useRef, useEffect } from 'react';\r\n// // // // // import './Components.css'; // Import your component-specific CSS file\r\n\r\n// // // // // import spriteImage from './img/background.png';\r\n\r\n// // // // // function CanvasDrawing() {\r\n// // // // //   // Create a ref for the canvas element\r\n// // // // //   const canvasRef = useRef(null);\r\n\r\n// // // // //   useEffect(() => {\r\n// // // // //     // const canvas = canvasRef.current;\r\n// // // // //     // const ctx = canvas.getContext('2d');\r\n\r\n// // // // //     const canvas = document.querySelector('canvas');\r\n// // // // //     const ctx = canvas.getContext('2d')\r\n// // // // //     // Set canvas dimensions\r\n// // // // //     canvas.width = 1024;\r\n// // // // //     canvas.height = 576;\r\n\r\n// // // // //     // Drawing code here\r\n// // // // //     // ctx.fillStyle = 'blue';\r\n// // // // //     ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n// // // // //     const gravity = 0.7\r\n\r\n// // // // //     const Components = () => {\r\n// // // // //       return (\r\n// // // // //         <div className=\"SpriteImage\">\r\n// // // // //           {/* Your component content */}\r\n// // // // //         </div>\r\n// // // // //       );\r\n// // // // //     };\r\n// // // // //     // Cleanup (optional)\r\n// // // // //     return () => {\r\n// // // // //       // You can perform cleanup here if needed\r\n// // // // //     };\r\n// // // // //   }, []); // Empty dependency array to run only once\r\n\r\n// // // // //   return (\r\n// // // // //     <div>\r\n// // // // //       <canvas ref={canvasRef}></canvas>\r\n// // // // //     </div>\r\n// // // // //   );\r\n// // // // // }\r\n\r\n// // // // // export default CanvasDrawing;\r\n\r\n\r\n// // // // import React, { useRef, useEffect, useState } from 'react';\r\n// // // // import './Components.css'; // Import your component-specific CSS file\r\n\r\n// // // // import spriteImage from './img/background.png';\r\n\r\n\r\n// // // // const initialPlayerState = {\r\n// // // //   position: {\r\n// // // //     x: 0,\r\n// // // //     y: 0\r\n// // // //   },\r\n// // // //   velocity: {\r\n// // // //     x: 0,\r\n// // // //     y: 0\r\n// // // //   },\r\n// // // //   offset: {\r\n// // // //     x: 0,\r\n// // // //     y: 0\r\n// // // //   },\r\n// // // //   imageSrc: './img/samuraiMack/Idle.png',\r\n// // // //   framesMax: 8,\r\n// // // //   scale: 2.5,\r\n// // // //   offset: {\r\n// // // //     x: 215,\r\n// // // //     y: 157\r\n// // // //   },\r\n// // // //   sprites: {\r\n// // // //     idle: {\r\n// // // //       imageSrc: './img/samuraiMack/Idle.png',\r\n// // // //       framesMax: 8\r\n// // // //     },\r\n// // // //     // ... Add other sprite definitions here\r\n// // // //   },\r\n// // // //   attackBox: {\r\n// // // //     offset: {\r\n// // // //       x: 100,\r\n// // // //       y: 50\r\n// // // //     },\r\n// // // //     width: 160,\r\n// // // //     height: 50\r\n// // // //   }\r\n// // // // };\r\n// // // // const initialEnemyState = {\r\n// // // //   position: {\r\n// // // //     x: 400,\r\n// // // //     y: 100\r\n// // // //   },\r\n// // // //   velocity: {\r\n// // // //     x: 0,\r\n// // // //     y: 0\r\n// // // //   },\r\n// // // //   color: 'blue',\r\n// // // //   offset: {\r\n// // // //     x: -50,\r\n// // // //     y: 0\r\n// // // //   },\r\n// // // //   imageSrc: './img/kenji/Idle.png',\r\n// // // //   framesMax: 4,\r\n// // // //   scale: 2.5,\r\n// // // //   offset: {\r\n// // // //     x: 215,\r\n// // // //     y: 167\r\n// // // //   },\r\n// // // //   sprites: {\r\n// // // //     idle: {\r\n// // // //       imageSrc: './img/kenji/Idle.png',\r\n// // // //       framesMax: 4\r\n// // // //     },\r\n// // // //     // ... Add other sprite definitions here\r\n// // // //   },\r\n// // // //   attackBox: {\r\n// // // //     offset: {\r\n// // // //       x: -170,\r\n// // // //       y: 50\r\n// // // //     },\r\n// // // //     width: 170,\r\n// // // //     height: 50\r\n// // // //   }\r\n// // // // };\r\n// // // // function CanvasDrawing() {\r\n// // // //   // Create a ref for the canvas element\r\n// // // //   const canvasRef = useRef(null);\r\n// // // //   const [player, setPlayer] = useState(initialPlayerState);\r\n// // // //   const [enemy, setEnemy] = useState(initialEnemyState);\r\n// // // //   const [keys, setKeys] = useState({\r\n// // // //     a: {\r\n// // // //       pressed: false\r\n// // // //     },\r\n// // // //     d: {\r\n// // // //       pressed: false\r\n// // // //     },\r\n// // // //     ArrowRight: {\r\n// // // //       pressed: false\r\n// // // //     },\r\n// // // //     ArrowLeft: {\r\n// // // //       pressed: false\r\n// // // //     }\r\n// // // //   });\r\n// // // //   useEffect(() => {\r\n// // // //     const canvas = canvasRef.current;\r\n// // // //     const ctx = canvas.getContext('2d');\r\n// // // //     const gravity = 0.7;\r\n\r\n// // // //     // Set canvas dimensions\r\n// // // //     canvas.width = 1024;\r\n// // // //     canvas.height = 576;\r\n\r\n// // // //     // Use the spriteImage as the background\r\n// // // //     const backgroundImage = new Image();\r\n// // // //     backgroundImage.src = spriteImage;\r\n    \r\n// // // //     // Once the image is loaded, draw it on the canvas\r\n// // // //     backgroundImage.onload = () => {\r\n// // // //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n    \r\n\r\n// // // //     // Other drawing code here\r\n// // // //     // ctx.fillStyle = 'blue';\r\n// // // //     // ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n// // // // // Draw the sprite image\r\n// // // // const playerImage = new Image();\r\n// // // // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\r\n// // // // playerImage.onload = () => {\r\n// // // //   // Draw the player image at the desired position (player.position.x, player.position.y)\r\n// // // //   ctx.drawImage(playerImage, player.position.x, player.position.y);\r\n// // // // };\r\n// // // // };\r\n// // // //     const handleKeyDown = (event) => {\r\n// // // //       // Update the keys state based on the pressed key\r\n// // // //       setKeys((prevKeys) => ({\r\n// // // //         ...prevKeys,\r\n// // // //         [event.key]: {\r\n// // // //           pressed: true\r\n// // // //         }\r\n// // // //       }));\r\n// // // //     };\r\n\r\n// // // //     const handleKeyUp = (event) => {\r\n// // // //       // Update the keys state when a key is released\r\n// // // //       setKeys((prevKeys) => ({\r\n// // // //         ...prevKeys,\r\n// // // //         [event.key]: {\r\n// // // //           pressed: false\r\n// // // //         }\r\n// // // //       }));\r\n// // // //     };\r\n\r\n// // // //     window.addEventListener('keydown', handleKeyDown);\r\n// // // //     window.addEventListener('keyup', handleKeyUp);\r\n    \r\n// // // //     // Cleanup (optional)\r\n// // // //     return () => {\r\n// // // //       // You can perform cleanup here if needed\r\n// // // //     };\r\n// // // //   }, []); // Empty dependency array to run only once\r\n\r\n// // // //   return (\r\n// // // //     <div>\r\n// // // //       <canvas ref={canvasRef}></canvas>\r\n// // // //     </div>\r\n// // // //   );\r\n// // // // }\r\n\r\n// // // // export default CanvasDrawing;\r\n\r\n\r\n\r\n\r\n// // // import React, { useRef, useEffect, useState } from 'react';\r\n// // // import './Components.css'; // Import your component-specific CSS file\r\n\r\n// // // import spriteImage from './Images/background.png';\r\n// // // import kenjiIdle from './Images/kenji/Idle.png';\r\n// // // import samuraiIdle from './Images/samuraiMack/Idle.png';\r\n\r\n// // // const initialPlayerState = {\r\n// // //   position: {\r\n// // //     x: 0,\r\n// // //     y: 0\r\n// // //   },\r\n// // //   velocity: {\r\n// // //     x: 0,\r\n// // //     y: 0\r\n// // //   },\r\n// // //   offset: {\r\n// // //     x: 0,\r\n// // //     y: 0\r\n// // //   },\r\n// // //   // imageSrc: './img/samuraiMack/Idle.png',\r\n// // //   imageSrc: samuraiIdle,\r\n// // //   framesMax: 8,\r\n// // //   scale: 2.5,\r\n// // //   offset: {\r\n// // //     x: 215,\r\n// // //     y: 157\r\n// // //   },\r\n// // //   sprites: {\r\n// // //     idle: {\r\n// // //       // imageSrc: './img/samuraiMack/Idle.png',\r\n// // //       imageSrc: samuraiIdle,\r\n// // //       framesMax: 8\r\n// // //     },\r\n// // //     // ... Add other sprite definitions here\r\n// // //   },\r\n// // //   attackBox: {\r\n// // //     offset: {\r\n// // //       x: 100,\r\n// // //       y: 50\r\n// // //     },\r\n// // //     width: 160,\r\n// // //     height: 50\r\n// // //   }\r\n// // // };\r\n// // // const initialEnemyState = {\r\n// // //   position: {\r\n// // //     x: 400,\r\n// // //     y: 100\r\n// // //   },\r\n// // //   velocity: {\r\n// // //     x: 0,\r\n// // //     y: 0\r\n// // //   },\r\n// // //   color: 'blue',\r\n// // //   offset: {\r\n// // //     x: -50,\r\n// // //     y: 0\r\n// // //   },\r\n// // //   // imageSrc: './img/kenji/Idle.png',\r\n// // //   imageSrc: kenjiIdle,\r\n// // //   framesMax: 4,\r\n// // //   scale: 2.5,\r\n// // //   offset: {\r\n// // //     x: 215,\r\n// // //     y: 167\r\n// // //   },\r\n// // //   sprites: {\r\n// // //     idle: {\r\n// // //       // imageSrc: './img/kenji/Idle.png',\r\n// // //       imageSrc: kenjiIdle,\r\n// // //       framesMax: 4\r\n// // //     },\r\n// // //     // ... Add other sprite definitions here\r\n// // //   },\r\n// // //   attackBox: {\r\n// // //     offset: {\r\n// // //       x: -170,\r\n// // //       y: 50\r\n// // //     },\r\n// // //     width: 170,\r\n// // //     height: 50\r\n// // //   }\r\n// // // };\r\n// // // function CanvasDrawing() {\r\n// // //   // Create a ref for the canvas element\r\n// // //   const canvasRef = useRef(null);\r\n// // //   const [player, setPlayer] = useState(initialPlayerState);\r\n// // //   const [enemy, setEnemy] = useState(initialEnemyState);\r\n// // //   const [keys, setKeys] = useState({\r\n// // //     a: {\r\n// // //       pressed: false\r\n// // //     },\r\n// // //     d: {\r\n// // //       pressed: false\r\n// // //     },\r\n// // //     ArrowRight: {\r\n// // //       pressed: false\r\n// // //     },\r\n// // //     ArrowLeft: {\r\n// // //       pressed: false\r\n// // //     }\r\n// // //   });\r\n// // //   useEffect(() => {\r\n// // //     const canvas = canvasRef.current;\r\n// // //     const ctx = canvas.getContext('2d');\r\n// // //     const gravity = 0.7;\r\n\r\n// // //     // Set canvas dimensions\r\n// // //     canvas.width = 1024;\r\n// // //     canvas.height = 576;\r\n\r\n// // //     // Use the spriteImage as the background\r\n// // //     const backgroundImage = new Image();\r\n// // //     backgroundImage.src = spriteImage;\r\n    \r\n// // //     // Once the image is loaded, draw it on the canvas\r\n// // //     backgroundImage.onload = () => {\r\n// // //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n    \r\n\r\n// // //     // Other drawing code here\r\n// // //     // ctx.fillStyle = 'blue';\r\n// // //     // ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n// // // // Draw the sprite image\r\n// // // const playerImage = new Image();\r\n// // // // playerImage.src = './img/kenji/Idle.png'; // Replace with the correct source\r\n// // // playerImage.src = kenjiIdle; \r\n// // // playerImage.onload = () => {\r\n// // //   // Draw the player image at the desired position (player.position.x, player.position.y)\r\n// // //   ctx.drawImage(playerImage, player.position.x, player.position.y);\r\n// // // };\r\n// // // };\r\n// // //     const handleKeyDown = (event) => {\r\n// // //       // Update the keys state based on the pressed key\r\n// // //       setKeys((prevKeys) => ({\r\n// // //         ...prevKeys,\r\n// // //         [event.key]: {\r\n// // //           pressed: true\r\n// // //         }\r\n// // //       }));\r\n// // //     };\r\n\r\n// // //     const handleKeyUp = (event) => {\r\n// // //       // Update the keys state when a key is released\r\n// // //       setKeys((prevKeys) => ({\r\n// // //         ...prevKeys,\r\n// // //         [event.key]: {\r\n// // //           pressed: false\r\n// // //         }\r\n// // //       }));\r\n// // //     };\r\n\r\n// // //     window.addEventListener('keydown', handleKeyDown);\r\n// // //     window.addEventListener('keyup', handleKeyUp);\r\n    \r\n// // //     // Cleanup (optional)\r\n// // //     return () => {\r\n// // //       // You can perform cleanup here if needed\r\n// // //     };\r\n// // //   }, []); // Empty dependency array to run only once\r\n\r\n// // //   return (\r\n// // //     <div>\r\n// // //       <canvas ref={canvasRef}></canvas>\r\n// // //     </div>\r\n// // //   );\r\n// // // }\r\n\r\n// // // export default CanvasDrawing;\r\n\r\n\r\n\r\n\r\n// // import React, { useRef, useEffect, useState } from 'react';\r\n// // import './Components.css';\r\n\r\n// // import spriteImage from './Images/background.png'; // Load the single sprite sheet\r\n// // import { AnimationFrame } from './animationFrame.js'; // You might need a utility for handling animations\r\n// // import kenjiImage from './Idle.png'; // Load the single sprite sheet\r\n\r\n// // const initialPlayerState = {\r\n// //   position: {\r\n// //     x: 0,\r\n// //     y: 0\r\n// //   },\r\n// //   velocity: {\r\n// //     x: 10,\r\n// //     y: 0\r\n// //   },\r\n// //   scale: 2.5,\r\n// // };\r\n\r\n// // // Define frame dimensions and animation parameters\r\n// // const kenjiFrameWidth = 64; // Width of a single frame in pixels\r\n// // const kenjiFrameHeight = 64; // Height of a single frame in pixels\r\n// // const kenjiTotalFrames = 8; // Total number of frames in Kenji's animation\r\n// // const kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\r\n\r\n// // const samuraiFrameWidth = 64; // Width of a single frame in pixels\r\n// // const samuraiFrameHeight = 64; // Height of a single frame in pixels\r\n// // const samuraiTotalFrames = 8; // Total number of frames in Samurai's animation\r\n// // const samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\r\n\r\n// // function CanvasDrawing() {\r\n// //   const canvasRef = useRef(null);\r\n// //   const [player, setPlayer] = useState(initialPlayerState);\r\n// //   const [currentFrame, setCurrentFrame] = useState(0);\r\n\r\n// //   useEffect(() => {\r\n// //     const canvas = canvasRef.current;\r\n// //     const ctx = canvas.getContext('2d');\r\n// //     const gravity = 0.7;\r\n\r\n// //     // Set canvas dimensions\r\n// //     canvas.width = 1024;\r\n// //     canvas.height = 576;\r\n\r\n// //     // Use the spriteImage as the background\r\n// //     const backgroundImage = new Image();\r\n// //     backgroundImage.src = spriteImage;\r\n// //     // const canvas = document.getElementById('myCanvas');\r\n// //     // const ctx = canvas.getContext('2d');\r\n// //     // const kenjiImage = new Image();\r\n// //     // kenjiImage.src = './Idle.png';\r\n    \r\n    \r\n    \r\n// //     // Create an animation frame object for each character\r\n// //     const kenjiAnimationFrame = new AnimationFrame({\r\n// //       image: kenjiImage,\r\n// //       frameWidth: kenjiFrameWidth,\r\n// //       frameHeight: kenjiFrameHeight,\r\n// //       totalFrames: kenjiTotalFrames,\r\n// //       animationSpeed: kenjiAnimationSpeed,\r\n      \r\n// //     });\r\n// //     kenjiImage.onload = function() {\r\n// //       ctx.drawImage(kenjiImage, 0,0); // Replace x and y with the coordinates where you want to draw the image.\r\n// //     };\r\n\r\n// //     const samuraiAnimationFrame = new AnimationFrame({\r\n// //       image: backgroundImage,\r\n// //       frameWidth: samuraiFrameWidth,\r\n// //       frameHeight: samuraiFrameHeight,\r\n// //       totalFrames: samuraiTotalFrames,\r\n// //       animationSpeed: samuraiAnimationSpeed,\r\n// //     });\r\n\r\n// //     // Define key state for controlling characters\r\n// //     const keys = {\r\n// //       ArrowLeft: false,\r\n// //       ArrowRight: false,\r\n// //       Space: false,\r\n// //     };\r\n\r\n// //     // Handle keydown event\r\n// //     const handleKeyDown = (event) => {\r\n// //       if (event.key === 'ArrowLeft') {\r\n// //         keys.ArrowLeft = true;\r\n// //       } else if (event.key === 'ArrowRight') {\r\n// //         keys.ArrowRight = true;\r\n// //       } else if (event.key === 'Space') {\r\n// //         keys.Space = true;\r\n// //       }\r\n// //     };\r\n\r\n// //     // Handle keyup event\r\n// //     const handleKeyUp = (event) => {\r\n// //       if (event.key === 'ArrowLeft') {\r\n// //         keys.ArrowLeft = false;\r\n// //       } else if (event.key === 'ArrowRight') {\r\n// //         keys.ArrowRight = false;\r\n// //       } else if (event.key === 'Space') {\r\n// //         keys.Space = false;\r\n// //       }\r\n// //     };\r\n\r\n// //     // Add event listeners for keydown and keyup\r\n// //     window.addEventListener('keydown', handleKeyDown);\r\n// //     window.addEventListener('keyup', handleKeyUp);\r\n\r\n// //     // Start the animation loop\r\n// //     const animate = () => {\r\n// //       ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n// //       // Draw the background image\r\n// //       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n// //       // Update the player's position based on keyboard input\r\n// //       if (keys.ArrowLeft) {\r\n// //         player.position.x -= player.velocity.x;\r\n// //       } else if (keys.ArrowRight) {\r\n// //         player.position.x += player.velocity.x;\r\n// //       }\r\n\r\n// //       // Draw Kenji character\r\n// //       kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\r\n\r\n// //       // Draw Samurai character\r\n// //       samuraiAnimationFrame.draw(ctx, player.position.x + 200, player.position.y);\r\n\r\n// //       // Update the current frame for each character's animation\r\n// //       setCurrentFrame((prevFrame) => prevFrame + 1);\r\n\r\n// //       requestAnimationFrame(animate);\r\n// //     };\r\n\r\n// //     animate();\r\n\r\n// //     // Cleanup (optional)\r\n// //     return () => {\r\n// //       // Remove event listeners or do other cleanup if needed\r\n// //       window.removeEventListener('keydown', handleKeyDown);\r\n// //       window.removeEventListener('keyup', handleKeyUp);\r\n// //     };\r\n// //   }, []); // Empty dependency array to run only once\r\n\r\n// //   return (\r\n// //     <div>\r\n// //       <canvas ref={canvasRef}></canvas>\r\n// //     </div>\r\n// //   );\r\n// // }\r\n\r\n// // export default CanvasDrawing;\r\n\r\n\r\n\r\n\r\n// import React, { useRef, useEffect, useState } from 'react';\r\n// import './Components.css';\r\n\r\n// import spriteImage from './Images/background.png'; // Load the single sprite sheet\r\n// import { AnimationFrame } from './animationFrame.js'; // You might need a utility for handling animations\r\n// import kenjiImage from './Idle1.png'; // Load the single sprite sheet\r\n\r\n// // ...\r\n\r\n// function CanvasDrawing() {\r\n//   // ...\r\n\r\n//   useEffect(() => {\r\n//     // ...\r\n\r\n//     // Use the kenjiImage as the character sprite\r\n//     const image = new Image();\r\n//     image.src = kenjiImage;\r\n\r\n//     // image.onload = function() {\r\n//       // Now, 'image' is an Image object, and you can use it safely.\r\n//       // ...\r\n//       ctx.drawImage(image, 0,0);\r\n//     };\r\n\r\n//     // ...\r\n//   }, []); // Empty dependency array to run only once\r\n\r\n//   // ...\r\n// }\r\n\r\n// export default CanvasDrawing;\r\n\r\n\r\n//   2\r\n// import React, { useRef, useEffect, useState } from 'react';\r\n// import './Components.css';\r\n\r\n// import spriteImage from './Images/background.png'; // Load the single sprite sheet\r\n// import { AnimationFrame } from './AnimationFrame.js'; // You might need a utility for handling animations\r\n// import kenjiImage from './Idle3 .png'; // Load the single sprite sheet\r\n// import samuraiImage from './fighter1.png'; // Load the single sprite sheet\r\n\r\n// const gravity = 0.7;\r\n// const initialPlayerState = {\r\n//   position: {\r\n//     x: 200,\r\n//     y: 400\r\n//   },\r\n//   velocity: {\r\n//     x: 10,\r\n//     y: 0\r\n//   },\r\n//   scale: 2.5,\r\n// };\r\n// // Define frame dimensions and animation parameters\r\n// const kenjiFrameWidth = 284; // Width of a single frame in pixels\r\n// const kenjiFrameHeight = 600; // Height of a single frame in pixels\r\n// const kenjiTotalFrames = 1; // Total number of frames in Kenji's animation\r\n// const kenjiAnimationSpeed = 10; // Speed of Kenji's animation (frames per second)\r\n\r\n// const samuraiFrameWidth = 284; // Width of a single frame in pixels\r\n// const samuraiFrameHeight = 600; // Height of a single frame in pixels\r\n// const samuraiTotalFrames = 1; // Total number of frames in Samurai's animation\r\n// const samuraiAnimationSpeed = 10; // Speed of Samurai's animation (frames per second)\r\n\r\n// function CanvasDrawing() {\r\n//   const canvasRef = useRef(null);\r\n//   const [player, setPlayer] = useState(initialPlayerState);\r\n//   const [currentFrame, setCurrentFrame] = useState(0);\r\n\r\n//   useEffect(() => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext('2d');\r\n//     // const gravity = 0.7;\r\n\r\n//     // Set canvas dimensions\r\n//     canvas.width = 1024;\r\n//     canvas.height = 576;\r\n\r\n//     // Use the spriteImage as the background\r\n//     const backgroundImage = new Image();\r\n//     backgroundImage.src = spriteImage;\r\n\r\n//     // Use kenjiImage as the character sprite\r\n//     const image = new Image();\r\n//     image.src = kenjiImage;\r\n\r\n//     image.onload = function() {\r\n//       // The 'image' is now fully loaded and can be safely used in your drawing logic.\r\n//       // For example, you can draw it here.\r\n//       ctx.drawImage(image, 50, 50); // Replace x and y with the coordinates where you want to draw the image.\r\n//     };\r\n// // Use samuraiImage as the character sprite\r\n//     const fighter = new Image();\r\n//     fighter.src = samuraiImage;\r\n\r\n//     fighter.onload = function() {\r\n//       // The 'image' is now fully loaded and can be safely used in your drawing logic.\r\n//       // For example, you can draw it here.\r\n//       ctx.drawImage(fighter, 50, 50); // Replace x and y with the coordinates where you want to draw the image.\r\n//     };\r\n\r\n\r\n//     // Create an animation frame object for each character\r\n//     const kenjiAnimationFrame = new AnimationFrame({\r\n//       image: image,\r\n//       frameWidth: kenjiFrameWidth,\r\n//       frameHeight: kenjiFrameHeight,\r\n//       totalFrames: kenjiTotalFrames,\r\n//       animationSpeed: kenjiAnimationSpeed,\r\n//     });\r\n\r\n//     const samuraiAnimationFrame = new AnimationFrame({\r\n//       image: fighter,\r\n//       frameWidth: samuraiFrameWidth,\r\n//       frameHeight: samuraiFrameHeight,\r\n//       totalFrames: samuraiTotalFrames,\r\n//       animationSpeed: samuraiAnimationSpeed,\r\n//     });\r\n\r\n//     // Define key state for controlling characters\r\n//     const keys = {\r\n//       ArrowLeft: false,\r\n//       ArrowRight: false,\r\n//       Space: false,\r\n//     };\r\n\r\n    \r\n\r\n//     // Handle keydown event\r\n//     const handleKeyDown = (event) => {\r\n//       if (event.key === 'ArrowLeft') {\r\n//         keys.ArrowLeft = true;\r\n//       } else if (event.key === 'ArrowRight') {\r\n//         keys.ArrowRight = true;\r\n//       } else if (event.key === 'Space') {\r\n//         keys.Space = true;\r\n//       }\r\n//     };\r\n\r\n    \r\n\r\n//     // Handle keyup event\r\n//     const handleKeyUp = (event) => {\r\n//       if (event.key === 'ArrowLeft') {\r\n//         keys.ArrowLeft = false;\r\n//       } else if (event.key === 'ArrowRight') {\r\n//         keys.ArrowRight = false;\r\n//       } else if (event.key === 'Space') {\r\n//         keys.Space = false;\r\n//       }\r\n//     };\r\n\r\n//     // Add event listeners for keydown and keyup\r\n//     window.addEventListener('keydown', handleKeyDown);\r\n//     window.addEventListener('keyup', handleKeyUp);\r\n\r\n//     // Start the animation loop\r\n//     const animate = () => {\r\n//       ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n//       // Draw the background image\r\n//       ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Update the player's position based on keyboard input\r\n//       if (keys.ArrowLeft) {\r\n//         player.position.x -= player.velocity.x;\r\n//       } else if (keys.ArrowRight) {\r\n//         player.position.x += player.velocity.x;\r\n//       }\r\n\r\n//       // Draw Kenji character\r\n//       kenjiAnimationFrame.draw(ctx, player.position.x, player.position.y);\r\n\r\n//       // Draw Samurai character\r\n//       samuraiAnimationFrame.draw(ctx, player.position.x + 400, player.position.y);\r\n\r\n//       // Update the current frame for each character's animation\r\n//       setCurrentFrame((prevFrame) => prevFrame + 1);\r\n\r\n//       requestAnimationFrame(animate);\r\n//     };\r\n\r\n//     animate();\r\n\r\n//     // Cleanup (optional)\r\n//     return () => {\r\n//       // Remove event listeners or do other cleanup if needed\r\n//       window.removeEventListener('keydown', handleKeyDown);\r\n//       window.removeEventListener('keyup', handleKeyUp);\r\n//     };\r\n//   }, []); // Empty dependency array to run only once\r\n\r\n//   return (\r\n//     <div>\r\n//       <canvas ref={canvasRef}></canvas>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default CanvasDrawing;\r\n\r\n\r\nimport React, { useRef, useEffect, useState } from 'react';\r\nimport './Components.css';\r\n\r\nimport spriteImage from './Images/background.png';\r\nimport { AnimationFrame } from './AnimationFrame.js';\r\nimport kenjiImage from './Idle3 .png';\r\nimport samuraiImage from './fighter1.png';\r\n\r\nconst gravity = 0.7;\r\nconst initialPlayer1State = {\r\n  position: {\r\n    x: 100,\r\n    y: 400\r\n  },\r\n  velocity: {\r\n    x: 10,\r\n    y: 0\r\n  },\r\n  scale: 2.5,\r\n};\r\n\r\nconst initialPlayer2State = {\r\n  position: {\r\n    x: 250,\r\n    y: 400\r\n  },\r\n  velocity: {\r\n    x: 10,\r\n    y: 0\r\n  },\r\n  scale: 2.5,\r\n};\r\n\r\nconst kenjiFrameWidth = 284;\r\nconst kenjiFrameHeight = 600;\r\nconst kenjiTotalFrames = 1;\r\nconst kenjiAnimationSpeed = 10;\r\n\r\nconst samuraiFrameWidth = 284;\r\nconst samuraiFrameHeight = 600;\r\nconst samuraiTotalFrames = 1;\r\nconst samuraiAnimationSpeed = 10;\r\n\r\nfunction CanvasDrawing() {\r\n  const canvasRef = useRef(null);\r\n  const [player1, setPlayer1] = useState(initialPlayer1State);\r\n  const [player2, setPlayer2] = useState(initialPlayer2State);\r\n  const [currentFrame, setCurrentFrame] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    canvas.width = 1024;\r\n    canvas.height = 576;\r\n\r\n    const backgroundImage = new Image();\r\n    backgroundImage.src = spriteImage;\r\n\r\n    const image = new Image();\r\n    image.src = kenjiImage;\r\n\r\n    image.onload = function () {\r\n      ctx.drawImage(image, 50, 50);\r\n    };\r\n\r\n    const fighter = new Image();\r\n    fighter.src = samuraiImage;\r\n\r\n    fighter.onload = function () {\r\n      ctx.drawImage(fighter, 50, 50);\r\n    };\r\n\r\n    const kenjiAnimationFrame = new AnimationFrame({\r\n      image: image,\r\n      frameWidth: kenjiFrameWidth,\r\n      frameHeight: kenjiFrameHeight,\r\n      totalFrames: kenjiTotalFrames,\r\n      animationSpeed: kenjiAnimationSpeed,\r\n    });\r\n\r\n    const samuraiAnimationFrame = new AnimationFrame({\r\n      image: fighter,\r\n      frameWidth: samuraiFrameWidth,\r\n      frameHeight: samuraiFrameHeight,\r\n      totalFrames: samuraiTotalFrames,\r\n      animationSpeed: samuraiAnimationSpeed,\r\n    });\r\n\r\n    const keys = {\r\n      a: false,\r\n      d: false,\r\n      w: false,\r\n      space: false,\r\n      ArrowLeft: false,\r\n      ArrowRight: false,\r\n      ArrowUp: false,\r\n      ArrowDown: false,\r\n    };\r\n\r\n    const handleKeyDown = (event) => {\r\n      if (event.key === 'a') {\r\n        keys.a = true;\r\n      } else if (event.key === 'd') {\r\n        keys.d = true;\r\n      } else if (event.key === 'w') {\r\n        keys.w = true;\r\n      } else if (event.key === ' ') {\r\n        keys.space = true;\r\n      } else if (event.key === 'ArrowLeft') {\r\n        keys.ArrowLeft = true;\r\n      } else if (event.key === 'ArrowRight') {\r\n        keys.ArrowRight = true;\r\n      } else if (event.key === 'ArrowUp') {\r\n        keys.ArrowUp = true;\r\n      } else if (event.key === 'ArrowDown') {\r\n        keys.ArrowDown = true;\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (event) => {\r\n      if (event.key === 'a') {\r\n        keys.a = false;\r\n      } else if (event.key === 'd') {\r\n        keys.d = false;\r\n      } else if (event.key === 'w') {\r\n        keys.w = false;\r\n      } else if (event.key === ' ') {\r\n        keys.space = false;\r\n      } else if (event.key === 'ArrowLeft') {\r\n        keys.ArrowLeft = false;\r\n      } else if (event.key === 'ArrowRight') {\r\n        keys.ArrowRight = false;\r\n      } else if (event.key === 'ArrowUp') {\r\n        keys.ArrowUp = false;\r\n      } else if (event.key === 'ArrowDown') {\r\n        keys.ArrowDown = false;\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    const animate = () => {\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n      if (keys.a) {\r\n        player1.position.x -= player1.velocity.x;\r\n      } else if (keys.d) {\r\n        player1.position.x += player1.velocity.x;\r\n      } else if (keys.w) {\r\n        // Handle jump for player 1\r\n        // Add your jump logic here\r\n      } else if (keys.space) {\r\n        // Handle attack for player 1\r\n        // Add your attack logic here\r\n\r\n        \r\n      }\r\n\r\n      if (keys.ArrowLeft) {\r\n        player2.position.x -= player2.velocity.x;\r\n      } else if (keys.ArrowRight) {\r\n        player2.position.x += player2.velocity.x;\r\n      } else if (keys.ArrowUp) {\r\n        // Handle jump for player 2\r\n        // Add your jump logic here\r\n      } else if (keys.ArrowDown) {\r\n        // Handle attack for player 2\r\n        // Add your attack logic here\r\n      }\r\n\r\n      kenjiAnimationFrame.draw(ctx, player1.position.x, player1.position.y);\r\n      samuraiAnimationFrame.draw(ctx, player2.position.x + 400, player2.position.y);\r\n\r\n      setCurrentFrame((prevFrame) => prevFrame + 1);\r\n\r\n      requestAnimationFrame(animate);\r\n    };\r\n\r\n    animate();\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={canvasRef}></canvas>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CanvasDrawing;\r\n"],"mappings":";;AAAA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAO,kBAAkB;AAEzB,OAAOC,WAAW,MAAM,yBAAyB;AACjD,SAASC,cAAc,QAAQ,qBAAqB;AACpD,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,YAAY,MAAM,gBAAgB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE1C,MAAMC,OAAO,GAAG,GAAG;AACnB,MAAMC,mBAAmB,GAAG;EAC1BC,QAAQ,EAAE;IACRC,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE;EACL,CAAC;EACDC,QAAQ,EAAE;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"},"metadata":{},"sourceType":"module","externalDependencies":[]}