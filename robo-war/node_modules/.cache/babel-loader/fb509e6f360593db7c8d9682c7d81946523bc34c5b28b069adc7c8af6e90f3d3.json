{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Meenal Jain\\\\Desktop\\\\robo_war\\\\robo-war\\\\src\\\\Canvas.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport spriteImage from './Images/background.png';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Canvas = props => {\n  _s();\n  const canvasRef = useRef(null);\n  let player;\n  let enemy;\n  let backgroundImage;\n  const keys = {\n    a: {\n      pressed: false\n    },\n    d: {\n      pressed: false\n    },\n    ArrowRight: {\n      pressed: false\n    },\n    ArrowLeft: {\n      pressed: false\n    }\n  };\n  let lastkey = ''; // Initialize lastkey with an empty string\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = 1024;\n    canvas.height = 576;\n    backgroundImage = new Image();\n    backgroundImage.src = spriteImage;\n    player = new Sprite({\n      position: {\n        x: 150,\n        y: 425\n      },\n      velocity: {\n        x: 0,\n        y: 0\n      }\n    });\n    enemy = new Sprite({\n      position: {\n        x: 450,\n        y: 425\n      },\n      velocity: {\n        x: 0,\n        y: 0\n      },\n      color: 'blue'\n    });\n    backgroundImage.onload = () => {\n      // Draw the background image\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n      // Draw the initial sprites\n      player.draw(ctx);\n      enemy.draw(ctx);\n    };\n\n    // Event listeners\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    function handleKeyDown(event) {\n      switch (event.key) {\n        case 'd':\n          keys.d.pressed = true;\n          lastkey = 'd';\n          break;\n        case 'a':\n          keys.a.pressed = true;\n          lastkey = 'a';\n          break;\n        case 'a':\n          keys.a.pressed = true;\n          lastkey = 'a';\n          break;\n        case ' ':\n          player.attack();\n          break;\n        case 'ArrowRight':\n          keys.ArrowRight.pressed = true;\n          enemy.lastkey = 'ArrowRight';\n          break;\n        case 'ArrowLeft':\n          keys.ArrowLeft.pressed = true;\n          enemy.lastkey = 'ArrowLeft';\n          break;\n      }\n    }\n    function handleKeyUp(event) {\n      switch (event.key) {\n        case 'd':\n          keys.d.pressed = false;\n          break;\n        case 'a':\n          keys.a.pressed = false;\n          break;\n        case 'ArrowRight':\n          keys.ArrowRight.pressed = true;\n          enemy.lastkey = 'ArrowRight';\n          break;\n        case 'ArrowLeft':\n          keys.ArrowLeft.pressed = true;\n          enemy.lastkey = 'ArrowLeft';\n          break;\n      }\n    }\n  }, []);\n  const gravity = 0.007;\n  class Sprite {\n    constructor({\n      position,\n      velocity,\n      color = 'red',\n      offset = {\n        x: 0,\n        y: 0\n      }\n    }) {\n      this.position = position;\n      this.velocity = velocity;\n      this.height = 150;\n      this.width = 50;\n      this.attackbox = {\n        position: {\n          x: this.position.x,\n          y: this.position.y\n        },\n        offset,\n        width: 100,\n        height: 50\n      };\n      this.isAttacking = '';\n      this.color = color;\n    }\n    draw(ctx) {\n      ctx.fillStyle = this.color;\n      ctx.fillRect(this.position.x, this.position.y, 50, this.height);\n      // attackbox\n      // if (this.isAttacking) {\n\n      ctx.fillStyle = 'green';\n      ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y, this.attackbox.width, this.attackbox.height);\n    }\n    // }\n\n    update(ctx) {\n      this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\n      this.attackbox.position.y = this.position.y;\n      this.position.x += this.velocity.x;\n      this.position.y += this.velocity.y;\n      if (this.position.y + this.height >= ctx.height) {\n        this.velocity.y = 0;\n        this.position.y = ctx.height - this.height;\n      } else {\n        this.velocity.y += gravity;\n      }\n    }\n    attack() {\n      this.isAttacking = true;\n      setTimeout(() => {\n        this.isAttacking = false;\n      }, 100);\n    }\n  }\n  function animate() {\n    const canvas = canvasRef.current;\n    if (canvas && player && enemy) {\n      const ctx = canvas.getContext('2d');\n\n      // Clear the canvas\n      ctx.fillStyle = 'black';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Draw the background image\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n\n      // Update and draw the sprites\n      player.update(canvas);\n      player.draw(ctx);\n      enemy.update(canvas);\n      enemy.draw(ctx);\n      player.velocity.x = 0;\n      enemy.velocity.x = 0;\n      if (keys.a.pressed && lastkey === 'a') {\n        player.velocity.x = -5;\n      } else if (keys.d.pressed && lastkey === 'd') {\n        player.velocity.x = 5;\n      }\n      if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\n        enemy.velocity.x = -5;\n      } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\n        enemy.velocity.x = 5;\n      }\n      // detect for collision\n      if (player.attackbox.position.x + player.attackbox.width >= enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width && player.attackbox.position.y + player.attackbox.height >= enemy.position.y && player.attackbox.position.y <= enemy.position.y + enemy.height && player.isAttacking) {\n        console.log('go');\n      }\n    }\n    window.requestAnimationFrame(animate);\n  }\n  useEffect(() => {\n    animate(); // Start the animation loop after the initial render\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 216,\n    columnNumber: 10\n  }, this);\n};\n_s(Canvas, \"1O11hef6JMAr7xpSnL0aZ5Ib60Q=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useRef","useEffect","spriteImage","jsxDEV","_jsxDEV","Canvas","props","_s","canvasRef","player","enemy","backgroundImage","keys","a","pressed","d","ArrowRight","ArrowLeft","lastkey","canvas","current","ctx","getContext","width","height","Image","src","Sprite","position","x","y","velocity","color","onload","drawImage","draw","window","addEventListener","handleKeyDown","handleKeyUp","event","key","attack","gravity","constructor","offset","attackbox","isAttacking","fillStyle","fillRect","update","setTimeout","animate","console","log","requestAnimationFrame","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Meenal Jain/Desktop/robo_war/robo-war/src/Canvas.jsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\r\nimport spriteImage from './Images/background.png';\r\n\r\nconst Canvas = (props) => {\r\n  const canvasRef = useRef(null);\r\n  let player;\r\n  let enemy;\r\n  let backgroundImage;\r\n  const keys = {\r\n    a: {\r\n      pressed: false,\r\n    },\r\n    d: {\r\n      pressed: false,\r\n    },\r\n    ArrowRight: {\r\n      pressed: false,\r\n    },\r\n    ArrowLeft: {\r\n      pressed: false,\r\n    },\r\n  };\r\n  let lastkey = ''; // Initialize lastkey with an empty string\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    canvas.width = 1024;\r\n    canvas.height = 576;\r\n\r\n    backgroundImage = new Image();\r\n    backgroundImage.src = spriteImage;\r\n\r\n    player = new Sprite({\r\n      position: { x: 150, y: 425 },\r\n      velocity: { x: 0, y: 0 },\r\n    });\r\n\r\n    enemy = new Sprite({\r\n      position: { x: 450, y: 425 },\r\n      velocity: { x: 0, y: 0 },\r\n      color: 'blue'\r\n    });\r\n\r\n    backgroundImage.onload = () => {\r\n      // Draw the background image\r\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n      // Draw the initial sprites\r\n      player.draw(ctx);\r\n      enemy.draw(ctx);\r\n    };\r\n\r\n    // Event listeners\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    function handleKeyDown(event) {\r\n      switch (event.key) {\r\n        case 'd':\r\n          keys.d.pressed = true;\r\n          lastkey = 'd';\r\n          break;\r\n        case 'a':\r\n          keys.a.pressed = true;\r\n          lastkey = 'a';\r\n          break;\r\n        case 'a':\r\n            keys.a.pressed = true;\r\n            lastkey = 'a';\r\n            break;\r\n          case ' ':\r\n            player.attack()  \r\n            break;\r\n        case 'ArrowRight':\r\n          keys.ArrowRight.pressed = true;\r\n          enemy.lastkey = 'ArrowRight';\r\n          break;\r\n          case 'ArrowLeft':\r\n          keys.ArrowLeft.pressed = true;\r\n          enemy.lastkey = 'ArrowLeft';\r\n          break;\r\n      }\r\n    }\r\n\r\n    function handleKeyUp(event) {\r\n      switch (event.key) {\r\n        case 'd':\r\n          keys.d.pressed = false;\r\n          break;\r\n        case 'a':\r\n          keys.a.pressed = false;\r\n          break;\r\n        case 'ArrowRight':\r\n          keys.ArrowRight.pressed = true;\r\n          enemy.lastkey = 'ArrowRight';\r\n          break;\r\n          case 'ArrowLeft':\r\n          keys.ArrowLeft.pressed = true;\r\n          enemy.lastkey = 'ArrowLeft';\r\n          break;\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  const gravity = 0.007;\r\n\r\n  class Sprite {\r\n    constructor({ position, velocity,color = 'red', offset= { x: 0, y: 0 } }) {\r\n      this.position = position;\r\n      this.velocity = velocity;\r\n      this.height = 150;\r\n      this.width = 50;\r\n      this.attackbox = {\r\n        position: {\r\n          x:this.position.x,\r\n          y:this.position.y\r\n        },\r\n        offset,\r\n        \r\n        width: 100 ,\r\n        height: 50\r\n      }\r\n      this.isAttacking = '';\r\n      this.color = color;\r\n    }\r\n\r\n    draw(ctx) {\r\n      ctx.fillStyle = this.color;\r\n      ctx.fillRect(this.position.x, this.position.y, 50, this.height);\r\n      // attackbox\r\n      // if (this.isAttacking) {\r\n\r\n      \r\n      ctx.fillStyle = 'green';\r\n      ctx.fillRect(this.attackbox.position.x, this.attackbox.position.y , this.attackbox.width , this.attackbox.height)\r\n    }\r\n  // }\r\n\r\n    update(ctx) {\r\n      this.attackbox.position.x = this.position.x - this.attackbox.offset.x;\r\n      this.attackbox.position.y = this.position.y;\r\n\r\n      this.position.x += this.velocity.x;\r\n      this.position.y += this.velocity.y;\r\n      if (this.position.y + this.height >= ctx.height) {\r\n        this.velocity.y = 0;\r\n        this.position.y = ctx.height - this.height;\r\n      } else {\r\n        this.velocity.y += gravity;\r\n      }\r\n    }\r\n      attack() {\r\n        this.isAttacking = true\r\n        setTimeout(() => {\r\n          this.isAttacking = false\r\n        }, 100\r\n        )\r\n        \r\n      \r\n    }\r\n  }\r\n\r\n  function animate() {\r\n    const canvas = canvasRef.current;\r\n\r\n     if (canvas && player && enemy) {\r\n      const ctx = canvas.getContext('2d');\r\n\r\n      // Clear the canvas\r\n      ctx.fillStyle = 'black';\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n      // Draw the background image\r\n      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\r\n\r\n      // Update and draw the sprites\r\n      player.update(canvas);\r\n      player.draw(ctx);\r\n\r\n      enemy.update(canvas);\r\n      enemy.draw(ctx);\r\n\r\n      player.velocity.x = 0;\r\n      enemy.velocity.x = 0;\r\n\r\n\r\n      if (keys.a.pressed && lastkey === 'a') {\r\n        player.velocity.x = -5;\r\n      } else if (keys.d.pressed && lastkey === 'd') {\r\n        player.velocity.x = 5;\r\n      }\r\n      if (keys.ArrowLeft.pressed && enemy.lastkey === 'ArrowLeft') {\r\n        enemy.velocity.x = -5;\r\n      } else if (keys.ArrowRight.pressed && enemy.lastkey === 'ArrowRight') {\r\n        enemy.velocity.x = 5;\r\n      }\r\n      // detect for collision\r\n      if (player.attackbox.position.x + player.attackbox.width >= \r\n        enemy.position.x && player.attackbox.position.x <= enemy.position.x + enemy.width &&\r\n        player.attackbox.position.y + player.attackbox.height >= enemy.position.y\r\n        && player.attackbox.position.y <= enemy.position.y + enemy.height &&\r\n        player.isAttacking) {\r\n        console.log('go');\r\n      }\r\n      \r\n    }\r\n\r\n    window.requestAnimationFrame(animate);\r\n  }\r\n\r\n  useEffect(() => {\r\n    animate(); // Start the animation loop after the initial render\r\n  }, []);\r\n\r\n  return <canvas ref={canvasRef} {...props} />;\r\n};\r\n\r\nexport default Canvas;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}